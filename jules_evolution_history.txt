
================================================================================
=== FILE: v01_20260114_1012_d0f3cc8.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import google.generativeai as genai
# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

genai.configure(api_key=API_KEY)
model = genai.GenerativeModel('gemini-1.5-pro-latest')

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(Task \d+:.*?)\*\*', content)
    if match:
        return match.group(1)
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'`html(.*?)`', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def run_agent():
    print("🤖 Jules is waking up...")
    task = get_next_task()
    if not task:
        print("✅ No pending tasks.")
        return

    print(f"📋 Picking up: {task}")
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    # Try reading library, defaulting to empty if missing
    try:
        library = read_file("tytax_library.json")
    except:
        library = ""

    prompt = f"""
    {agents_doc}
    CONTEXT:
    {arch_doc}
    CURRENT LIBRARY SAMPLE:
    {library[:1000]}...
    CURRENT CODE:
    {current_code}
    YOUR MISSION:
    Implement: "{task}"
    OUTPUT RULES:
    1. Return ONLY the full, updated index.html code.
    2. No explanations.
    """

    print("💡 Thinking...")
    response = model.generate_content(prompt)
    new_code = extract_code_block(response.text)

    if not new_code:
        print("❌ Error: No code generated.")
        return

    print("💾 Saving...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is live.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")

if __name__ == "__main__":
    run_agent()


================================================================================
=== FILE: v02_20260114_1029_311ce4d.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import google.generativeai as genai

# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

genai.configure(api_key=API_KEY)

# FIXED: Switched to 'gemini-1.5-flash' (Stable & Fast)
# 'gemini-1.5-pro-latest' is deprecated and causes 404 errors.
model = genai.GenerativeModel('gemini-1.5-flash')

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(Task \d+:.*?)\*\*', content)
    if match:
        return match.group(1)
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def run_agent():
    print("🤖 Jules is waking up...")
    task = get_next_task()
    if not task:
        print("✅ No pending tasks.")
        return

    print(f"📋 Picking up: {task}")
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    try:
        library = read_file("tytax_library.json")
    except:
        library = ""

    prompt = f"""
    {agents_doc}
    CONTEXT:
    {arch_doc}
    CURRENT LIBRARY SAMPLE:
    {library[:1000]}...
    CURRENT CODE:
    {current_code}
    YOUR MISSION:
    Implement: "{task}"
    OUTPUT RULES:
    1. Return ONLY the full, updated index.html code.
    2. No explanations.
    """

    print("💡 Thinking... (Asking Gemini)")
    try:
        response = model.generate_content(prompt)
        new_code = extract_code_block(response.text)
    except Exception as e:
        print(f"❌ Gemini API Error: {e}")
        return

    if not new_code:
        print("❌ Error: No code generated.")
        return

    print("💾 Saving...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is live.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")

if __name__ == "__main__":
    run_agent()


================================================================================
=== FILE: v03_20260114_1044_0b4f5b6.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json

# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")
# We use the direct API URL to bypass library version issues
API_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={API_KEY}"

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    # Matches: - [ ] **Task 001: Title**
    match = re.search(r'- \[ \] \*\*(Task \d+:.*?)\*\*', content)
    if match:
        return match.group(1)
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{
            "parts": [{"text": prompt}]
        }]
    }
    response = requests.post(API_URL, headers=headers, data=json.dumps(data))
    
    if response.status_code != 200:
        print(f"❌ API Error {response.status_code}: {response.text}")
        return None
        
    try:
        return response.json()['candidates'][0]['content']['parts'][0]['text']
    except (KeyError, IndexError):
        print(f"❌ Unexpected Response Format: {response.text}")
        return None

def run_agent():
    print("🤖 Jules is waking up (Direct Mode)...")
    task = get_next_task()
    if not task:
        print("✅ No pending tasks.")
        return

    print(f"📋 Picking up: {task}")
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    try:
        library = read_file("tytax_library.json")
    except:
        library = ""

    prompt = f"""
    {agents_doc}
    CONTEXT:
    {arch_doc}
    CURRENT LIBRARY SAMPLE:
    {library[:1000]}...
    CURRENT CODE:
    {current_code}
    YOUR MISSION:
    Implement: "{task}"
    OUTPUT RULES:
    1. Return ONLY the full, updated index.html code.
    2. No explanations.
    3. Ensure the code is complete.
    """

    print("💡 Thinking... (Sending Request)")
    raw_response = ask_gemini(prompt)
    
    if not raw_response:
        return

    new_code = extract_code_block(raw_response)

    if not new_code:
        print("❌ Error: Valid HTML not found in response.")
        return

    print("💾 Saving...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is live.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")

if __name__ == "__main__":
    run_agent()


================================================================================
=== FILE: v04_20260114_1049_01c7688.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json

# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

# PRIORITY LIST: Tries Gemini 3 first. Falls back if access is denied.
MODELS_TO_TRY = [
    "gemini-3-pro-preview",    # The "Smartest" Brain (Paid/Preview)
    "gemini-3-flash-preview",  # Fast & New
    "gemini-2.5-pro",          # Reliable Previous Gen
    "gemini-2.0-flash-exp",    # Standard Flash
    "gemini-1.5-pro",          # Legacy Backup
    "gemini-1.5-flash"         # Ultimate Safety Net
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(Task \d+:.*?)\*\*', content)
    if match:
        return match.group(1)
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}]
    }
    
    # "The Handshake": Try each model until one says "Hello"
    for model_name in MODELS_TO_TRY:
        print(f"🔄 Attempting connection to brain: {model_name}...")
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={API_KEY}"
        
        try:
            response = requests.post(url, headers=headers, data=json.dumps(data))
            
            if response.status_code == 200:
                print(f"✅ CONNECTED! Using {model_name}.")
                return response.json()['candidates'][0]['content']['parts'][0]['text']
            elif response.status_code == 404:
                 print(f"⚠️ {model_name} not found (might be paid-only). Trying next...")
            else:
                print(f"⚠️ {model_name} error ({response.status_code}). Trying next...")
        except Exception as e:
            print(f"⚠️ Connection error with {model_name}: {e}")

    print("❌ All models failed. Please check your API Key.")
    return None

def run_agent():
    print("🤖 Jules is waking up (Gemini 3 Upgrade)...")
    task = get_next_task()
    if not task:
        print("✅ No pending tasks.")
        return

    print(f"📋 Picking up: {task}")
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    try:
        library = read_file("tytax_library.json")
    except:
        library = ""

    prompt = f"""
    {agents_doc}
    CONTEXT:
    {arch_doc}
    CURRENT LIBRARY SAMPLE:
    {library[:1000]}...
    CURRENT CODE:
    {current_code}
    YOUR MISSION:
    Implement: "{task}"
    OUTPUT RULES:
    1. Return ONLY the full, updated index.html code.
    2. Ensure the code is complete.
    """

    print("💡 Thinking... (Connecting to Google Cloud)")
    raw_response = ask_gemini(prompt)
    
    if not raw_response:
        return

    new_code = extract_code_block(raw_response)
    if not new_code:
        print("❌ Error: Valid HTML not found in response.")
        return

    print("💾 Saving...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is live.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")

if __name__ == "__main__":
    run_agent()


================================================================================
=== FILE: v05_20260114_1633_c84f7e4.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time

# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

MODELS_TO_TRY = [
    "gemini-2.0-flash-exp",
    "gemini-2.5-pro",
    "gemini-3-flash-preview"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(Task \d+:.*?)\*\*', content)
    if match:
        return match.group(1)
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    
    for model_name in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={API_KEY}"
        max_retries = 3
        for attempt in range(max_retries):
            print(f"🔄 Connecting to {model_name} (Attempt {attempt+1}/{max_retries})...")
            try:
                response = requests.post(url, headers=headers, data=json.dumps(data))
                if response.status_code == 200:
                    print(f"✅ CONNECTED! Using {model_name}.")
                    return response.json()['candidates'][0]['content']['parts'][0]['text']
                elif response.status_code in [429, 503]:
                    wait_time = 20 * (attempt + 1)
                    print(f"⚠️ Rate Limit. Cooling down for {wait_time}s...")
                    time.sleep(wait_time)
                else:
                    print(f"❌ Error {response.status_code}")
                    break
            except Exception as e:
                print(f"⚠️ Connection error: {e}")
                time.sleep(5)
    return None

def run_agent():
    print("🤖 Jules is waking up (Safe Mode)...")
    task = get_next_task()
    if not task:
        print("✅ No pending tasks.")
        return

    print(f"📋 Picking up: {task}")
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    
    # 📏 Measure current size for safety check
    original_lines = len(current_code.splitlines())
    print(f"📏 Current File Size: {original_lines} lines")

    try:
        library = read_file("tytax_library.json")
    except:
        library = ""

    prompt = f"""
    {agents_doc}
    CONTEXT:
    {arch_doc}
    CURRENT LIBRARY SAMPLE:
    {library[:1000]}...
    CURRENT CODE:
    {current_code}
    YOUR MISSION:
    Implement: "{task}"
    CRITICAL OUTPUT RULES:
    1. Return the FULL index.html code. Do not summarize.
    2. Do not remove existing features.
    3. If the code is too long, stop and output nothing.
    """

    print("💡 Thinking...")
    raw_response = ask_gemini(prompt)
    
    if not raw_response:
        return

    new_code = extract_code_block(raw_response)
    if not new_code:
        print("❌ Error: Valid HTML not found.")
        return

    # 🛡️ SAFETY VALVE: Check if file shrank suspiciously
    new_lines = len(new_code.splitlines())
    print(f"📏 New File Size: {new_lines} lines")
    
    if new_lines < (original_lines * 0.8): # If new file is < 80% of old file
        print(f"🚨 SAFETY TRIGGERED: New code is too short ({new_lines} vs {original_lines}). Aborting save.")
        print("⚠️ Jules tried to delete code or failed to generate the full file.")
        return

    print("💾 Saving (Safety Check Passed)...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is live.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")

if __name__ == "__main__":
    run_agent()


================================================================================
=== FILE: v06_20260114_1644_eae3a14.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time

# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

MODELS_TO_TRY = [
    "gemini-2.0-flash-exp",
    "gemini-2.5-pro",
    "gemini-3-flash-preview"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    # OLD REGEX: r'- \[ \] \*\*(Task \d+:.*?)\*\*'
    # NEW REGEX: Matches ANY bold text after an unchecked box
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    if match:
        return match.group(1).strip()
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    # Matches the specific task title we found and checks the box
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    
    for model_name in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={API_KEY}"
        max_retries = 3
        for attempt in range(max_retries):
            print(f"🔄 Connecting to {model_name} (Attempt {attempt+1}/{max_retries})...")
            try:
                response = requests.post(url, headers=headers, data=json.dumps(data))
                if response.status_code == 200:
                    print(f"✅ CONNECTED! Using {model_name}.")
                    return response.json()['candidates'][0]['content']['parts'][0]['text']
                elif response.status_code in [429, 503]:
                    wait_time = 20 * (attempt + 1)
                    print(f"⚠️ Rate Limit. Cooling down for {wait_time}s...")
                    time.sleep(wait_time)
                else:
                    print(f"❌ Error {response.status_code}")
                    break
            except Exception as e:
                print(f"⚠️ Connection error: {e}")
                time.sleep(5)
    return None

def run_agent():
    print("🤖 Jules is waking up (Flexible Mode)...")
    task = get_next_task()
    if not task:
        print("✅ No pending tasks.")
        return

    print(f"📋 Picking up: {task}")
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    
    # 📏 Measure current size for safety check
    original_lines = len(current_code.splitlines())
    print(f"📏 Current File Size: {original_lines} lines")

    try:
        library = read_file("tytax_library.json")
    except:
        library = ""

    prompt = f"""
    {agents_doc}
    CONTEXT:
    {arch_doc}
    CURRENT LIBRARY SAMPLE:
    {library[:1000]}...
    CURRENT CODE:
    {current_code}
    YOUR MISSION:
    Implement: "{task}"
    CRITICAL OUTPUT RULES:
    1. Return the FULL index.html code. Do not summarize.
    2. Do not remove existing features.
    3. If the code is too long, stop and output nothing.
    """

    print("💡 Thinking...")
    raw_response = ask_gemini(prompt)
    
    if not raw_response:
        return

    new_code = extract_code_block(raw_response)
    if not new_code:
        print("❌ Error: Valid HTML not found.")
        return

    # 🛡️ SAFETY VALVE: Check if file shrank suspiciously
    new_lines = len(new_code.splitlines())
    print(f"📏 New File Size: {new_lines} lines")
    
    if new_lines < (original_lines * 0.8): # If new file is < 80% of old file
        print(f"🚨 SAFETY TRIGGERED: New code is too short ({new_lines} vs {original_lines}). Aborting save.")
        print("⚠️ Jules tried to delete code or failed to generate the full file.")
        return

    print("💾 Saving (Safety Check Passed)...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is live.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")

if __name__ == "__main__":
    run_agent()


================================================================================
=== FILE: v07_20260114_1650_e8618ef.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time
import html.parser

# --- CONFIGURATION ---
REPO_PATH = "."
API_KEY = os.environ.get("GEMINI_API_KEY")
MAX_RUNTIME_MINUTES = 45  # GitHub Actions limit is usually 60m
START_TIME = time.time()

if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set!")

MODELS_TO_TRY = [
    "gemini-2.0-flash-exp",
    "gemini-2.5-pro",
    "gemini-3-flash-preview"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    # Matches any bold text after an unchecked box
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    if match:
        return match.group(1).strip()
    return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    if "<!DOCTYPE html>" in response_text:
        return response_text
    return None

def validate_html_structure(code):
    """Simple self-correction check."""
    errors = []
    if "<!DOCTYPE html>" not in code:
        errors.append("Missing <!DOCTYPE html> declaration.")
    if "</html>" not in code:
        errors.append("Missing closing </html> tag.")
    if "<script" in code and "</script>" not in code:
        errors.append("Unclosed <script> tag detected.")
    
    # Python's built-in parser to catch nesting errors
    try:
        parser = html.parser.HTMLParser()
        parser.feed(code)
    except Exception as e:
        errors.append(f"HTML Parsing Error: {str(e)}")
        
    return errors

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    
    for model_name in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={API_KEY}"
        max_retries = 3
        for attempt in range(max_retries):
            # print(f"🔄 Connecting to {model_name}...") # Quiet mode for logs
            try:
                response = requests.post(url, headers=headers, data=json.dumps(data))
                if response.status_code == 200:
                    return response.json()['candidates'][0]['content']['parts'][0]['text']
                elif response.status_code in [429, 503]:
                    time.sleep(20 * (attempt + 1))
                else:
                    break
            except Exception:
                time.sleep(5)
    return None

def process_single_task():
    task = get_next_task()
    if not task:
        print("✅ No pending tasks found.")
        return False # Stop the loop

    print(f"\n📋 STARTING TASK: {task}")
    
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    original_lines = len(current_code.splitlines())

    prompt = f"""
    {agents_doc}
    CONTEXT: {arch_doc}
    CURRENT CODE: {current_code}
    YOUR MISSION: Implement: "{task}"
    RULES: Return FULL index.html. No shortening.
    """

    # --- ATTEMPT 1: GENERATE ---
    print("💡 Thinking (Attempt 1)...")
    raw_response = ask_gemini(prompt)
    if not raw_response: return True # Skip to next loop if API fails

    new_code = extract_code_block(raw_response)
    if not new_code:
        print("❌ Failed to extract code.")
        return True

    # --- SELF-CORRECTION LOOP ---
    validation_errors = validate_html_structure(new_code)
    
    # Size check is a critical validation error too
    new_lines = len(new_code.splitlines())
    if new_lines < (original_lines * 0.8):
        validation_errors.append(f"Critical Code Loss: File shrank from {original_lines} to {new_lines} lines.")

    if validation_errors:
        print(f"⚠️ SELF-CORRECTION TRIGGERED: {validation_errors}")
        print("🔧 Asking Jules to fix his own mistakes...")
        
        correction_prompt = f"""
        You generated code for "{task}" but it failed validation:
        ERRORS: {'; '.join(validation_errors)}
        
        PREVIOUS ATTEMPT:
        {new_code}
        
        MISSION: Fix these specific errors and return the COMPLETE valid index.html.
        """
        
        raw_response = ask_gemini(correction_prompt)
        fixed_code = extract_code_block(raw_response)
        
        if fixed_code:
            print("✅ Fix received. Verifying again...")
            # Re-validate the fix
            if len(fixed_code.splitlines()) > (original_lines * 0.8):
                new_code = fixed_code # Accept the fix
            else:
                print("❌ Fix failed size check. Aborting task safely.")
                return True
        else:
            print("❌ Fix failed to generate code. Aborting task.")
            return True

    # --- SAVE & COMMIT ---
    print("💾 Saving verified code...")
    write_file("index.html", new_code)

    print("📦 Committing...")
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    print("🚀 Pushing...")
    try:
        repo.remotes.origin.push()
        print(f"✅ Success! {task} is LIVE.")
    except Exception as e:
        print(f"⚠️ Push failed: {e}")
        
    return True # Continue the loop

def run_loop():
    print("🤖 Jules is entering CONTINUOUS MODE...")
    while True:
        # Check time limit (leave 5 mins buffer for cleanup)
        elapsed = (time.time() - START_TIME) / 60
        if elapsed > (MAX_RUNTIME_MINUTES - 5):
            print("⏰ Time limit reached. Stopping to prevent timeout.")
            break
            
        # Run one task
        more_work = process_single_task()
        
        if not more_work:
            print("🎉 All tasks complete! Going to sleep.")
            break
            
        print("⏳ Taking a breath (10s) before next task...")
        time.sleep(10)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v08_20260114_1657_0ea670b.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time
import html.parser

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg" # Found from your screenshot
SITE_URL = "https://tytax-elite.onrender.com"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")
if not RENDER_API_KEY:
    print("⚠️ WARNING: RENDER_API_KEY is missing. Production checks will be skipped.")

MODELS_TO_TRY = ["gemini-2.0-flash-exp", "gemini-2.5-pro", "gemini-3-flash-preview"]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match: return match.group(1).strip()
    return response_text if "<!DOCTYPE html>" in response_text else None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        try:
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            if resp.status_code == 200:
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
        except: pass
    return None

def wait_for_render_deploy():
    """Polls Render API to verify deployment success."""
    if not RENDER_API_KEY: return True
    
    print("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    # Wait for the NEW deploy to start (it takes a few seconds after git push)
    time.sleep(10) 
    
    for _ in range(20): # Check for ~5 minutes
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code != 200: 
                print(f"⚠️ Render API Error: {resp.status_code}")
                continue
                
            latest_deploy = resp.json()[0]['deploy']
            status = latest_deploy['status']
            commit_id = latest_deploy['commit']['id']
            
            print(f"📡 Deploy Status: {status} (Commit: {commit_id[:7]})")
            
            if status == "live":
                print("✅ Render says: Deployment LIVE.")
                return True
            if status in ["build_failed", "update_failed", "canceled"]:
                print(f"❌ Render says: Deployment FAILED ({status}).")
                return False
                
        except Exception as e:
            print(f"⚠️ Monitoring error: {e}")
            
        time.sleep(15)
        
    print("⏳ Timed out waiting for Render. Assuming success or manual check needed.")
    return True

def check_site_health():
    """Pings the live URL to ensure it's not a white screen."""
    try:
        print(f"💓 Pinging {SITE_URL}...")
        resp = requests.get(SITE_URL, timeout=10)
        if resp.status_code == 200:
            print("✅ Site is responding (HTTP 200).")
            return True
        else:
            print(f"❌ Site is DOWN (HTTP {resp.status_code}).")
            return False
    except Exception as e:
        print(f"❌ Site ping failed: {e}")
        return False

def emergency_revert(task_name):
    print("🚨 INITIATING EMERGENCY ROLLBACK 🚨")
    repo = git.Repo(REPO_PATH)
    # Revert the last commit to undo the damage
    repo.git.revert("HEAD", no_edit=True)
    repo.remotes.origin.push()
    print(f"✅ Rollback pushed. {task_name} has been undone to save the site.")

def process_single_task():
    task = get_next_task()
    if not task: return False

    print(f"\n📋 STARTING TASK: {task}")
    
    # Load Context
    agents_doc = read_file("AGENTS.md")
    arch_doc = read_file("ARCHITECTURE.md")
    current_code = read_file("index.html")
    original_lines = len(current_code.splitlines())

    # Generate
    prompt = f"{agents_doc}\nCONTEXT: {arch_doc}\nCURRENT CODE: {current_code}\nMISSION: Implement '{task}'\nRULES: Return FULL index.html."
    print("💡 Thinking...")
    raw_response = ask_gemini(prompt)
    if not raw_response: return True

    new_code = extract_code_block(raw_response)
    if not new_code or len(new_code.splitlines()) < (original_lines * 0.8):
        print("❌ Safety Check Failed (Code too short or invalid). Aborting.")
        return True

    # Save & Push
    print("💾 Saving and Pushing...")
    write_file("index.html", new_code)
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    mark_task_done(task) # Mark done locally, but we might undo this if it fails
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    repo.remotes.origin.push()

    # --- PRODUCTION VERIFICATION ---
    deploy_success = wait_for_render_deploy()
    
    if deploy_success:
        # Double check: Is the site actually reachable?
        health_success = check_site_health()
        if health_success:
            print(f"🎉 SUCCESS! {task} is live and healthy.")
        else:
            print("⚠️ Deploy passed but Site Health failed.")
            emergency_revert(task)
    else:
        print("❌ Deploy failed.")
        emergency_revert(task)
        
    return True

def run_loop():
    print("🤖 Jules Level 4 (Production Aware) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(10)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v09_20260114_1733_509f1ac.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time
import html.parser
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

# --- FORCE UNBUFFERED OUTPUT ---
# This ensures logs appear in GitHub Actions IMMEDIATELY
def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")
if not RENDER_API_KEY:
    log("⚠️ WARNING: RENDER_API_KEY is missing. Production checks will be skipped.")

MODELS_TO_TRY = ["gemini-2.0-flash-exp", "gemini-2.5-pro", "gemini-3-flash-preview"]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match: return match.group(1).strip()
    return response_text if "<!DOCTYPE html>" in response_text else None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        try:
            log(f"🔄 Trying model: {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            if resp.status_code == 200:
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
            log(f"⚠️ Status {resp.status_code} from {model}")
        except Exception as e:
            log(f"❌ Error hitting API: {e}")
    return None

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except Exception as e:
            log(f"⚠️ Monitor Error: {e}")
        time.sleep(15)
    log("⏳ Monitor timed out (assuming success).")
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    
    current_code = read_file("index.html")
    agents_doc = read_file("AGENTS.md")
    
    prompt = f"{agents_doc}\nCURRENT CODE LENGTH: {len(current_code)}\nTASK: {task}\nOUTPUT: Full index.html only."
    
    log("💡 Asking Gemini...")
    raw_response = ask_gemini(prompt)
    if not raw_response: 
        log("❌ No response from AI.")
        return True

    new_code = extract_code_block(raw_response)
    if not new_code or len(new_code.splitlines()) < 2000:
        log("❌ Safety Check Failed: Code too short.")
        return True

    log("💾 Saving to index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    log("🚀 Pushing to GitHub...")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules Level 4 (LOUD MODE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v10_20260114_1740_30711f4.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time
import html.parser
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")
if not RENDER_API_KEY:
    log("⚠️ WARNING: RENDER_API_KEY is missing. Production checks will be skipped.")

# 🔄 NEW STRATEGY: Try the best (Preview) models first. 
# If they are overloaded (429), fall back to the Stable Paid model (1.5 Pro) so the job finishes.
MODELS_TO_TRY = [
    "gemini-3-pro-preview",    # <--- 1. The Best (Coding Powerhouse)
    "gemini-3-flash-preview",  # <--- 2. The Fast Backup
    "gemini-2.0-flash-exp",    # <--- 3. The Experimental Flash
    "gemini-1.5-pro-latest"    # <--- 4. The "Safety Net" (Stable, High Limits)
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match: return match.group(1).strip()
    return response_text if "<!DOCTYPE html>" in response_text else None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    
    for model in MODELS_TO_TRY:
        # Use v1beta to access Preview/Pro models correctly
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        try:
            log(f"🔄 Connecting to {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            
            if resp.status_code == 200:
                log(f"✅ Success! Connected to {model}.")
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
            
            elif resp.status_code == 429:
                log(f"⚠️ {model} is busy (Rate Limit). Trying next model...")
                time.sleep(2) # Short pause before switching
            else:
                log(f"⚠️ Status {resp.status_code} from {model}")
                
        except Exception as e:
            log(f"❌ Error hitting API: {e}")
            
    return None

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except Exception as e:
            log(f"⚠️ Monitor Error: {e}")
        time.sleep(15)
    log("⏳ Monitor timed out (assuming success).")
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    
    current_code = read_file("index.html")
    agents_doc = read_file("AGENTS.md")
    
    prompt = f"{agents_doc}\nCURRENT CODE LENGTH: {len(current_code)}\nTASK: {task}\nOUTPUT: Full index.html only."
    
    log("💡 Asking Gemini...")
    raw_response = ask_gemini(prompt)
    if not raw_response: 
        log("❌ No response from AI (All models failed).")
        return True

    new_code = extract_code_block(raw_response)
    if not new_code or len(new_code.splitlines()) < 2000:
        log("❌ Safety Check Failed: Code too short.")
        return True

    log("💾 Saving to index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    log("🚀 Pushing to GitHub...")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules Level 4 (GEMINI 3 PRIORITY) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v11_20260114_1803_72f7405.py
=== DATE: 01/16/2026 10:11:04
================================================================================

import os
import re
import git
import requests
import json
import time
import html.parser
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")
if not RENDER_API_KEY:
    log("⚠️ WARNING: RENDER_API_KEY is missing. Production checks will be skipped.")

# 🔄 FIXED MODEL LIST: Corrected names to prevent 404 errors
MODELS_TO_TRY = [
    "gemini-2.0-flash-exp",    # 1. Experimental (Fast & Smart)
    "gemini-1.5-pro",          # 2. Stable Pro (The Reliability King) - FIXED NAME
    "gemini-1.5-flash",        # 3. Stable Flash (The "Emergency" Backup)
    "gemini-1.0-pro"           # 4. Legacy (Last Resort)
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match: return match.group(1).strip()
    return response_text if "<!DOCTYPE html>" in response_text else None

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    
    for model in MODELS_TO_TRY:
        # Using standard v1beta endpoint
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        try:
            log(f"🔄 Connecting to {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            
            if resp.status_code == 200:
                log(f"✅ Success! Connected to {model}.")
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
            
            elif resp.status_code == 429:
                log(f"⚠️ {model} is busy (Rate Limit). Switching...")
                time.sleep(1) 
            elif resp.status_code == 404:
                log(f"❌ {model} not found (404). Check spelling.")
            else:
                log(f"⚠️ Status {resp.status_code} from {model}")
                
        except Exception as e:
            log(f"❌ Error hitting API: {e}")
            
    return None

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except Exception as e:
            log(f"⚠️ Monitor Error: {e}")
        time.sleep(15)
    log("⏳ Monitor timed out (assuming success).")
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    
    current_code = read_file("index.html")
    agents_doc = read_file("AGENTS.md")
    
    prompt = f"{agents_doc}\nCURRENT CODE LENGTH: {len(current_code)}\nTASK: {task}\nOUTPUT: Full index.html only."
    
    log("💡 Asking Gemini...")
    raw_response = ask_gemini(prompt)
    if not raw_response: 
        log("❌ No response from AI (All models failed).")
        return True

    new_code = extract_code_block(raw_response)
    if not new_code or len(new_code.splitlines()) < 2000:
        log("❌ Safety Check Failed: Code too short.")
        return True

    log("💾 Saving to index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    log("🚀 Pushing to GitHub...")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules Level 4 (FINAL FIX) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v12_20260114_1814_62b10d7.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

# --- FORCE UNBUFFERED OUTPUT ---
def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")
if not RENDER_API_KEY:
    log("⚠️ WARNING: RENDER_API_KEY is missing. Production checks will be skipped.")

# 🎯 SNIPER LIST: ONLY High-IQ Experimental Models. 
# We removed the "dumber" stable models.
MODELS_TO_TRY = [
    "gemini-2.0-flash-exp"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match: return match.group(1).strip()
    return response_text if "<!DOCTYPE html>" in response_text else None

def ask_gemini_stubborn(prompt):
    """
    Siege Mode: Keeps hitting the High-IQ model until it answers.
    No downgrading to dumber models.
    """
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    model = "gemini-2.0-flash-exp"
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"

    wait_time = 5 # Start with 5 seconds wait
    max_retries = 10 # Try 10 times (approx 5 mins of fighting)

    for attempt in range(max_retries):
        try:
            log(f"🔄 Connecting to {model} (Attempt {attempt+1}/{max_retries})...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            
            if resp.status_code == 200:
                log(f"✅ Success! {model} answered.")
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
            
            elif resp.status_code == 429:
                log(f"⚠️ {model} is busy (Rate Limit). Waiting {wait_time}s...")
                time.sleep(wait_time)
                wait_time *= 1.5 # Exponential Backoff: Wait longer next time (5s -> 7.5s -> 11s...)
            elif resp.status_code == 503:
                log(f"⚠️ {model} Overloaded (503). Cooling down for 20s...")
                time.sleep(20)
            else:
                log(f"❌ Critical Error {resp.status_code}: {resp.text}")
                # Don't give up immediately on 500s, retry once or twice
                time.sleep(5)
                
        except Exception as e:
            log(f"❌ Connection Error: {e}")
            time.sleep(5)
            
    log("❌ Failed to get code after maximum retries.")
    return None

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except Exception as e:
            log(f"⚠️ Monitor Error: {e}")
        time.sleep(15)
    log("⏳ Monitor timed out (assuming success).")
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    
    current_code = read_file("index.html")
    agents_doc = read_file("AGENTS.md")
    
    prompt = f"{agents_doc}\nCURRENT CODE LENGTH: {len(current_code)}\nTASK: {task}\nOUTPUT: Full index.html only."
    
    log(f"💡 Asking Gemini 2.0 Flash Exp (Stubborn Mode)...")
    raw_response = ask_gemini_stubborn(prompt)
    if not raw_response: 
        log("❌ No response from AI.")
        return True

    new_code = extract_code_block(raw_response)
    if not new_code or len(new_code.splitlines()) < 2000:
        log("❌ Safety Check Failed: Code too short.")
        return True

    log("💾 Saving to index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    log("🚀 Pushing to GitHub...")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules (HIGH-IQ ONLY) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v13_20260114_1823_4252da6.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

# --- FORCE UNBUFFERED OUTPUT ---
def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")
if not RENDER_API_KEY:
    log("⚠️ WARNING: RENDER_API_KEY is missing. Production checks will be skipped.")

# 🎯 SNIPER LIST: High-IQ Models Only
MODELS_TO_TRY = [
    "gemini-2.0-flash-exp"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_code_block(response_text):
    match = re.search(r'```html(.*?)```', response_text, re.DOTALL)
    if match: return match.group(1).strip()
    return response_text if "<!DOCTYPE html>" in response_text else None

def ask_gemini_stubborn(prompt):
    """
    Siege Mode with MAX OUTPUT TOKENS to prevent 'Code too short' errors.
    """
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    
    # ⚡ FORCE MAX TOKENS: Telling the AI to write the whole file
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {
            "maxOutputTokens": 8192,  # Maximum allowed for this model
            "temperature": 0.2        # Lower creativity to ensure stability
        }
    }

    wait_time = 5 
    max_retries = 10 

    for attempt in range(max_retries):
        try:
            log(f"🔄 Connecting to Gemini 2.0 (Attempt {attempt+1}/{max_retries})...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            
            if resp.status_code == 200:
                log(f"✅ Success! Gemini answered.")
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
            
            elif resp.status_code == 429:
                log(f"⚠️ Rate Limit (429). Waiting {wait_time}s...")
                time.sleep(wait_time)
                wait_time *= 1.5 
            elif resp.status_code == 503:
                log(f"⚠️ Overloaded (503). Cooling down for 20s...")
                time.sleep(20)
            else:
                log(f"❌ Error {resp.status_code}: {resp.text}")
                time.sleep(5)
                
        except Exception as e:
            log(f"❌ Connection Error: {e}")
            time.sleep(5)
            
    log("❌ Failed to get code after maximum retries.")
    return None

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except Exception as e:
            log(f"⚠️ Monitor Error: {e}")
        time.sleep(15)
    log("⏳ Monitor timed out (assuming success).")
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    
    current_code = read_file("index.html")
    agents_doc = read_file("AGENTS.md")
    
    # 🔍 UPDATED PROMPT: Explicitly demanding full code
    prompt = f"""
    {agents_doc}
    TASK: {task}
    CURRENT CODE LENGTH: {len(current_code)} characters
    
    CRITICAL INSTRUCTION:
    You must rewrite the ENTIRE index.html file to implement the task.
    DO NOT summarize. DO NOT skip sections. DO NOT use placeholders like ''.
    If the code is cut off, the system will reject it.
    
    OUTPUT: Full index.html only.
    """
    
    log(f"💡 Asking Gemini (Max Capacity Mode)...")
    raw_response = ask_gemini_stubborn(prompt)
    if not raw_response: 
        log("❌ No response from AI.")
        return True

    new_code = extract_code_block(raw_response)
    
    # Validation
    if not new_code:
        log("❌ Error: Valid HTML block not found in response.")
        return True
        
    if len(new_code.splitlines()) < 2000:
        log(f"❌ Safety Check Failed: Code is too short ({len(new_code.splitlines())} lines). Retrying next loop...")
        return True

    log("💾 Saving to index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): implemented {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    
    log("🚀 Pushing to GitHub...")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules (ANTI-LAZINESS MODE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v14_20260114_1824_94c6dd8.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# 🎯 SNIPER LIST: Surgical Mode works even on "dumber" models if needed, 
# but we keep High-IQ for accuracy.
MODELS_TO_TRY = ["gemini-2.0-flash-exp", "gemini-1.5-pro"]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def ask_gemini(prompt):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192} # Plenty for a patch
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        try:
            log(f"🔄 Connecting to {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            if resp.status_code == 200:
                log(f"✅ Success! {model} answered.")
                return resp.json()['candidates'][0]['content']['parts'][0]['text']
            elif resp.status_code == 429:
                log(f"⚠️ {model} Busy. Waiting 5s...")
                time.sleep(5)
            else:
                log(f"⚠️ Error {resp.status_code}")
        except Exception as e:
            log(f"❌ API Error: {e}")
    return None

def apply_patch(original_code, patch_text):
    """
    Parses a SEARCH/REPLACE block and applies it to the code.
    """
    # Regex to find the blocks
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    
    if not matches:
        return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
        else:
            # Fallback: Try stripping whitespace
            if search_block.strip() in new_code:
                log("⚠️ Exact match failed, trying loose match...")
                new_code = new_code.replace(search_block.strip(), replace_block)
            else:
                return None, f"Could not find code block:\n{search_block[:50]}..."
                
    return new_code, "Success"

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 SURGICAL TASK: {task}")
    current_code = read_file("index.html")
    
    # 🔍 SURGICAL PROMPT
    prompt = f"""
    CONTEXT: You are a surgical coding agent. The file is too large to rewrite.
    TASK: {task}
    
    INSTRUCTIONS:
    1. Identify the SPECIFIC code block in `index.html` that needs changing.
    2. Output a SEARCH/REPLACE block.
    3. The SEARCH block must be an EXACT COPY of the existing code (including whitespace) so I can find it.
    4. The REPLACE block is your fixed version.
    
    FORMAT:
    <<<<<<< SEARCH
    (Paste exact existing code here)
    =======
    (Paste new code here)
    >>>>>>> REPLACE
    
    CURRENT CODE:
    {current_code}
    """
    
    log("💡 Asking Gemini for a Patch...")
    response = ask_gemini(prompt)
    if not response: return True

    log("💉 Applying Patch...")
    new_code, message = apply_patch(current_code, response)
    
    if not new_code:
        log(f"❌ Patch Failed: {message}")
        # Retry logic could go here, but for now we skip to save infinite loops
        return True

    # Validate size didn't drop catastrophically
    if len(new_code) < len(current_code) * 0.9:
        log("❌ Safety: Patch deleted too much code.")
        return True

    log("💾 Saving Patched index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): surgical fix for {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules Level 5 (SURGICAL MODE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v15_20260114_1827_88cc719.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# 🎯 THE HIERARCHY
# 1. Try the Best (Gemini 3).
# 2. If jammed, try the Fast Genius (Gemini 2.0).
# 3. No Gemini 1.5.
MODELS_TO_TRY = [
    "gemini-3-pro-preview",
    "gemini-3-flash-preview",
    "gemini-2.0-flash-exp"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    content = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def ask_gemini_smart_fallback(prompt):
    headers = {'Content-Type': 'application/json'}
    # Surgical Max Tokens
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192} 
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        # Give each model 3 chances (approx 30s of effort)
        # If it's truly jammed, move to the next smart one.
        for attempt in range(3):
            try:
                log(f"🔄 Connecting to {model} (Attempt {attempt+1}/3)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                
                if resp.status_code == 200:
                    log(f"✅ Success! {model} answered.")
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                
                elif resp.status_code == 429:
                    log(f"⚠️ {model} Busy. Waiting 5s...")
                    time.sleep(5)
                elif resp.status_code == 404:
                    log(f"❌ {model} Not Found. Skipping.")
                    break
                else:
                    log(f"⚠️ Status {resp.status_code}. Retrying...")
                    time.sleep(2)
            except Exception as e:
                log(f"❌ Network Error: {e}")
                time.sleep(2)
        
        log(f"⏭️ {model} timed out. Falling back to next best model...")
                
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    
    if not matches:
        return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        else:
            clean_search = search_block.strip()
            if clean_search in new_code:
                new_code = new_code.replace(clean_search, replace_block.strip())
                success_count += 1
            else:
                return None, f"Could not find code block:\n{search_block[:50]}..."
                
    return new_code, f"Applied {success_count} patches."

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 SURGICAL TASK: {task}")
    current_code = read_file("index.html")
    
    prompt = f"""
    CONTEXT: You are an expert engineer.
    TASK: {task}
    TARGET FILE: index.html
    
    INSTRUCTIONS:
    1. Find the exact code to fix.
    2. Output a SEARCH/REPLACE block.
    
    FORMAT:
    <<<<<<< SEARCH
    (Exact existing code)
    =======
    (New code)
    >>>>>>> REPLACE
    
    CURRENT CODE:
    {current_code}
    """
    
    log(f"💡 Asking Smart Models (3.0 -> 2.0)...")
    response = ask_gemini_smart_fallback(prompt)
    if not response: 
        log("❌ Failed to get response from any High-IQ model.")
        return True

    log("💉 Applying Patch...")
    new_code, message = apply_patch(current_code, response)
    
    if not new_code:
        log(f"❌ Patch Failed: {message}")
        return True

    if len(new_code) < len(current_code) * 0.9:
        log("❌ Safety: File shrank too much.")
        return True

    log("💾 Saving Patched index.html...")
    write_file("index.html", new_code)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(f"feat(jules): {task}")
    mark_task_done(task)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"docs: marked {task} as done")
    repo.remotes.origin.push()

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        repo.git.revert("HEAD", no_edit=True)
        repo.remotes.origin.push()
        
    return True

def run_loop():
    log("🤖 Jules (SMART FALLBACK) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v16_20260114_1839_d9e3f96.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# 🎯 MODEL HIERARCHY (Priority Order)
# Fallback strategy: Try Best -> Fast -> Legacy
MODELS_TO_TRY = [
    "gemini-3-pro-preview",
    "gemini-3-flash-preview",
    "gemini-2.5-pro",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite",
    "gemini-2.0-flash-001",       # Legacy (Retires March 2026)
    "gemini-2.0-flash-lite-001"   # Legacy (Retires March 2026)
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except FileNotFoundError:
        return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

# 1) ROBUSTNO VAĐENJE TEKSTA
def extract_text_from_response(response_json):
    """
    Safely extracts text from the deep JSON structure.
    Returns None if structure is missing or empty, avoiding KeyErrors.
    """
    try:
        if not response_json: return None
        candidates = response_json.get("candidates", [])
        if not candidates: return None
        
        candidate = candidates[0]
        content = candidate.get("content", {})
        parts = content.get("parts", [])
        
        # Combine all text parts (ignoring non-text parts if any)
        full_text = "".join([p.get("text", "") for p in parts if "text" in p])
        
        return full_text if full_text.strip() else None
    except Exception as e:
        log(f"⚠️ Extraction Logic Error: {e}")
        return None

# 2, 3, 4) ROBUST REQUEST & FALLBACK LOGIC
def ask_gemini_robust(prompt):
    url_base = "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    headers = {'Content-Type': 'application/json'}
    
    # Disable Safety Filters to minimize "False Success" (200 OK but blocked content)
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192},
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }
    
    for model in MODELS_TO_TRY:
        url = url_base.format(model=model)
        full_url = f"{url}?key={GEMINI_API_KEY}"
        
        # Retry loop for a single model
        max_retries_per_model = 3
        base_delay = 5 # seconds
        
        for attempt in range(max_retries_per_model):
            try:
                log(f"🔄 Connecting to {model} (Attempt {attempt+1}/{max_retries_per_model})...")
                resp = requests.post(full_url, headers=headers, data=json.dumps(data))
                
                # --- CASE: HTTP 200 (Success... or is it?) ---
                if resp.status_code == 200:
                    try:
                        resp_json = resp.json()
                        text = extract_text_from_response(resp_json)
                        
                        if text:
                            log(f"✅ Success! {model} answered.")
                            return text
                        else:
                            # 2) DETEKCIJA LAŽNOG SUCCESSA
                            finish_reason = resp_json.get("candidates", [{}])[0].get("finishReason", "UNKNOWN")
                            log(f"⚠️ Warning: 200 OK but NO CONTENT from {model}. Reason: {finish_reason}")
                            
                            # Dump JSON for debugging
                            with open("last_gemini_debug.json", "w", encoding="utf-8") as f:
                                json.dump(resp_json, f, indent=2)
                            log("💾 Saved debug info to last_gemini_debug.json")
                            
                            # Treat as a failure, trigger retry
                            time.sleep(2) 
                            continue

                    except json.JSONDecodeError:
                        log(f"❌ Parse Error: Invalid JSON from {model}. Raw: {resp.text[:100]}")
                        continue

                # --- CASE: RATE LIMIT (429) ---
                elif resp.status_code == 429:
                    # 4) PAMETNI BACKOFF
                    retry_after = int(resp.headers.get("Retry-After", 0))
                    # Exponential backoff + Jitter
                    sleep_time = (base_delay * (2 ** attempt)) + random.uniform(0, 3)
                    wait_time = max(retry_after, sleep_time)
                    
                    log(f"⏳ {model} Rate Limited (429). Cooling down for {wait_time:.1f}s...")
                    time.sleep(wait_time)
                
                # --- CASE: OVERLOADED (503) ---
                elif resp.status_code == 503:
                    log(f"⚠️ {model} Overloaded (503). Waiting 20s...")
                    time.sleep(20)
                
                # --- CASE: CLIENT ERRORS (400, 404, 403) ---
                elif 400 <= resp.status_code < 500:
                    log(f"❌ Client Error {resp.status_code} from {model}: {resp.text}")
                    break # Don't retry client errors (wrong model name, invalid key), move to next model
                
                # --- CASE: SERVER ERRORS (500, 502, 504) ---
                else:
                    log(f"⚠️ Server Error {resp.status_code} from {model}. Retrying...")
                    time.sleep(5)

            except Exception as e:
                log(f"❌ Network/API Error: {e}")
                time.sleep(5)
        
        log(f"⏭️ {model} exhausted retries. Falling back to next model in list...")

    log("❌ All models failed to generate code.")
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    
    if not matches:
        return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        else:
            clean_search = search_block.strip()
            if clean_search in new_code:
                new_code = new_code.replace(clean_search, replace_block.strip())
                success_count += 1
            else:
                return None, f"Could not find code block:\n{search_block[:50]}..."
                
    return new_code, f"Applied {success_count} patches."

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                latest_deploy = data[0]['deploy']
                status = latest_deploy['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 SURGICAL TASK: {task}")
    current_code = read_file("index.html")
    
    prompt = f"""
    CONTEXT: You are an expert engineer.
    TASK: {task}
    TARGET FILE: index.html
    
    INSTRUCTIONS:
    1. Find the exact code to fix.
    2. Output a SEARCH/REPLACE block.
    
    FORMAT:
    <<<<<<< SEARCH
    (Exact existing code)
    =======
    (New code)
    >>>>>>> REPLACE
    
    CURRENT CODE:
    {current_code}
    """
    
    log(f"💡 Asking Gemini (Smart Fallback Mode)...")
    response = ask_gemini_robust(prompt)
    if not response: 
        log("❌ Failed to get response from any model.")
        return True

    log("💉 Applying Patch...")
    new_code, message = apply_patch(current_code, response)
    
    if not new_code:
        log(f"❌ Patch Failed: {message}")
        return True

    if len(new_code) < len(current_code) * 0.9:
        log("❌ Safety: File shrank too much.")
        return True

    log("💾 Saving Patched index.html...")
    write_file("index.html", new_code)
    
    try:
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        mark_task_done(task)
        repo.git.add("BACKLOG.md")
        repo.index.commit(f"docs: marked {task} as done")
        repo.remotes.origin.push()
        log("🚀 Pushed to GitHub.")
    except Exception as e:
        log(f"❌ Git Error: {e}")
        return True

    if wait_for_render_deploy():
        log("🎉 Deploy Success!")
    else:
        log("🚨 Deploy Failed! Reverting...")
        try:
            repo.git.revert("HEAD", no_edit=True)
            repo.remotes.origin.push()
        except: pass
        
    return True

def run_loop():
    log("🤖 Jules (ROBUST V6) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v17_20260114_1953_acce32c.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

# Max retries for "Self-Correction" (The Critic Loop)
MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# 🎯 MODEL HIERARCHY
# We use the smartest models for both Coding AND Verification
MODELS_TO_TRY = [
    "gemini-2.0-flash-exp",    # Best Balance (Smart + Fast)
    "gemini-1.5-pro",          # Reliable Backup
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except FileNotFoundError: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        if not response_json: return None
        candidates = response_json.get("candidates", [])
        if not candidates: return None
        parts = candidates[0].get("content", {}).get("parts", [])
        full_text = "".join([p.get("text", "") for p in parts if "text" in p])
        return full_text if full_text.strip() else None
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    """
    Generic API wrapper. 
    model_hint: 'coder' or 'critic' (could use different temps in future)
    """
    url_base = "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.2}, # Low temp for precision
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }
    
    for model in MODELS_TO_TRY:
        url = url_base.format(model=model) + f"?key={GEMINI_API_KEY}"
        for attempt in range(3):
            try:
                log(f"🔄 [{model_hint.upper()}] Connecting to {model}...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: return text
                    else: 
                        log(f"⚠️ Empty response. Retrying...")
                        time.sleep(2)
                elif resp.status_code == 429:
                    log(f"⏳ Rate Limit. Waiting 5s...")
                    time.sleep(5 + attempt)
                else:
                    break # Client error, try next model
            except Exception as e:
                log(f"❌ Net Error: {e}")
                time.sleep(2)
    return None

def apply_patch(original_code, patch_text):
    """
    Applies the patch using Fuzzy Matching logic.
    """
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    
    if not matches:
        return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    
    for search_block, replace_block in matches:
        # 1. Exact Match
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
            continue
            
        # 2. Loose Match (Strip whitespace)
        if search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            continue
            
        # 3. Aggressive Strip Match (Remove all whitespace)
        # This is risky but effective for simple JS edits
        def clean(s): return "".join(s.split())
        if clean(search_block) in clean(new_code):
            # We can't use replace() on the cleaned string directly.
            # We skip this for now to avoid corruption, trusting the AI will retry.
            log(f"⚠️ Fuzzy match found but skipped for safety (whitespace mismatch).")
            continue
    
    if success_count == 0:
        return None, "Could not find any code blocks to replace."
        
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    """
    The Critic: Analyzes the NEW code to see if the logic actually holds up.
    Returns: (bool is_passed, str feedback)
    """
    if original_code == new_code:
        return False, "The code did not change at all."

    prompt = f"""
    ROLE: You are a Senior Code Reviewer.
    TASK: {task}
    
    I have applied a patch to the file. 
    Analyze the NEW CODE below.
    
    CHECKLIST:
    1. Did the specific logic requested in the TASK actually change?
    2. Are there any obvious React errors (e.g., missing dependencies in useEffect, mutating state directly)?
    3. If the task was "Fix Chart", does the chart data prop actually update?
    
    NEW CODE SNAPSHOT (relevant parts):
    {new_code[:10000]} 
    ... (truncated for length) ...
    {new_code[-5000:]}
    
    OUTPUT FORMAT:
    If the fix looks correct:
    PASS
    
    If the fix is broken or incomplete:
    FAIL: [Reason why it is broken]
    """
    
    response = ask_gemini_robust(prompt, model_hint="critic")
    if not response: return True, "Critic failed to respond, assuming pass." # Fail open to avoid deadlocks
    
    if "PASS" in response:
        return True, "Verified."
    else:
        # Extract the failure reason
        return False, response.replace("FAIL:", "").strip()

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                status = data[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    current_code = read_file("index.html")
    
    # --- THE SELF-CORRECTION LOOP ---
    critique_history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        
        prompt = f"""
        CONTEXT: Expert React Engineer.
        TASK: {task}
        TARGET FILE: index.html
        
        {critique_history}
        
        INSTRUCTIONS:
        1. Find the exact code to fix.
        2. Output a SEARCH/REPLACE block.
        
        FORMAT:
        <<<<<<< SEARCH
        (Exact existing code)
        =======
        (New code)
        >>>>>>> REPLACE
        
        CURRENT CODE:
        {current_code}
        """
        
        response = ask_gemini_robust(prompt, model_hint="coder")
        if not response: continue

        # 1. Try to Apply Patch
        log("💉 Applying Patch...")
        new_code, message = apply_patch(current_code, response)
        
        if not new_code:
            log(f"❌ Patch Failed: {message}")
            critique_history = f"PREVIOUS ATTEMPT FAILED: The SEARCH block didn't match the file exactly. Be more precise."
            continue

        # 2. Verify with The Critic (QA Step)
        log("🕵️ Running QA Verification...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        
        if is_valid:
            log(f"✅ QA Passed: {feedback}")
            # SAVE AND COMMIT
            write_file("index.html", new_code)
            try:
                repo = git.Repo(REPO_PATH)
                repo.git.add(all=True)
                repo.index.commit(f"feat(jules): {task}")
                mark_task_done(task)
                repo.git.add("BACKLOG.md")
                repo.index.commit(f"docs: marked {task} as done")
                repo.remotes.origin.push()
                log("🚀 Pushed to GitHub.")
                if wait_for_render_deploy(): log("🎉 Deploy Success!")
                else: log("🚨 Deploy Failed (Render Check).")
            except Exception as e:
                log(f"❌ Git Error: {e}")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"PREVIOUS FIX REJECTED BY QA: {feedback}\nPlease fix the logic error and try again."
            # Loop continues to next attempt...

    log("❌ Task Failed after max retries.")
    return True # Return True to move to next loop/exit, prevents infinite hanging

def run_loop():
    log("🤖 Jules Level 7 (SELF-HEALING) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v18_20260114_2000_42f96a9.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

# Max retries for "Self-Correction" (The Critic Loop)
MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# 🎯 MODEL HIERARCHY (RESTORED GEMINI 3)
# We need Gemini 3's reasoning to get the PATCH format right.
MODELS_TO_TRY = [
    "gemini-3-pro-preview",    # 1. The Mastermind (Best at coding)
    "gemini-3-flash-preview",  # 2. The Fast Mastermind
    "gemini-2.0-flash-exp",    # 3. The Fallback
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except FileNotFoundError: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        if not response_json: return None
        candidates = response_json.get("candidates", [])
        if not candidates: return None
        parts = candidates[0].get("content", {}).get("parts", [])
        full_text = "".join([p.get("text", "") for p in parts if "text" in p])
        return full_text if full_text.strip() else None
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    url_base = "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.2}, 
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }
    
    for model in MODELS_TO_TRY:
        url = url_base.format(model=model) + f"?key={GEMINI_API_KEY}"
        # Only try once per model to avoid wasting time on broken models
        try:
            log(f"🔄 [{model_hint.upper()}] Connecting to {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data))
            
            if resp.status_code == 200:
                text = extract_text_from_response(resp.json())
                if text: return text
                else: log(f"⚠️ {model} returned empty content.")
            elif resp.status_code == 429:
                log(f"⏳ {model} Rate Limited. Switching...")
                time.sleep(2)
            else:
                log(f"❌ {model} Error {resp.status_code}.")
        except Exception as e:
            log(f"❌ Network Error: {e}")
            time.sleep(1)
            
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    
    if not matches:
        return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
            continue
        
        # Loose match
        if search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            continue
    
    if success_count == 0:
        return None, "Could not find any code blocks to replace."
        
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code:
        return False, "The code did not change at all."

    prompt = f"""
    ROLE: You are a Senior Code Reviewer.
    TASK: {task}
    
    I have applied a patch to the file. 
    Analyze the NEW CODE below.
    
    CHECKLIST:
    1. Did the specific logic requested in the TASK actually change?
    2. Are there any obvious React errors?
    
    NEW CODE SNAPSHOT (relevant parts):
    {new_code[:10000]} 
    ... (truncated) ...
    {new_code[-5000:]}
    
    OUTPUT FORMAT:
    If the fix looks correct:
    PASS
    
    If the fix is broken:
    FAIL: [Reason]
    """
    
    response = ask_gemini_robust(prompt, model_hint="critic")
    if not response: return True, "Critic failed to respond."
    
    if "PASS" in response: return True, "Verified."
    else: return False, response.replace("FAIL:", "").strip()

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    time.sleep(10)
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if not data: continue 
                status = data[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False

    log(f"\n📋 STARTING TASK: {task}")
    current_code = read_file("index.html")
    
    critique_history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        
        prompt = f"""
        CONTEXT: Expert React Engineer.
        TASK: {task}
        TARGET FILE: index.html
        
        {critique_history}
        
        INSTRUCTIONS:
        1. Find the exact code to fix.
        2. Output a SEARCH/REPLACE block.
        3. Make sure the SEARCH block matches EXACTLY.
        
        FORMAT:
        <<<<<<< SEARCH
        (Exact existing code)
        =======
        (New code)
        >>>>>>> REPLACE
        
        CURRENT CODE:
        {current_code}
        """
        
        response = ask_gemini_robust(prompt, model_hint="coder")
        if not response: continue

        log("💉 Applying Patch...")
        new_code, message = apply_patch(current_code, response)
        
        if not new_code:
            log(f"❌ Patch Failed: {message}")
            critique_history = f"PREVIOUS ATTEMPT FAILED: The SEARCH block didn't match. Be precise."
            continue

        log("🕵️ Running QA Verification...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        
        if is_valid:
            log(f"✅ QA Passed: {feedback}")
            write_file("index.html", new_code)
            try:
                repo = git.Repo(REPO_PATH)
                repo.git.add(all=True)
                repo.index.commit(f"feat(jules): {task}")
                mark_task_done(task)
                repo.git.add("BACKLOG.md")
                repo.index.commit(f"docs: marked {task} as done")
                repo.remotes.origin.push()
                log("🚀 Pushed to GitHub.")
                if wait_for_render_deploy(): log("🎉 Deploy Success!")
            except Exception as e:
                log(f"❌ Git Error: {e}")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED: {feedback}"

    log("❌ Task Failed after max retries.")
    return True 

def run_loop():
    log("🤖 Jules Level 8 (GEMINI 3 RETURN) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v19_20260114_2114_a1ab84b.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

MODELS_TO_TRY = [
    "gemini-3-pro-preview",    
    "gemini-3-flash-preview", 
    "gemini-2.0-flash-exp"     
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except FileNotFoundError: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        if not response_json: return None
        candidates = response_json.get("candidates", [])
        if not candidates: return None
        candidate = candidates[0]
        content = candidate.get("content", {})
        parts = content.get("parts", [])
        full_text = "".join([p.get("text", "") for p in parts if "text" in p])
        return full_text if full_text.strip() else None
    except: return None

def ask_gemini_v6_style(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}, 
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        wait_time = 5
        for attempt in range(5): 
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/5)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: return text
                elif resp.status_code == 429:
                    log(f"⏳ Busy. Waiting {wait_time}s...")
                    time.sleep(wait_time)
                    wait_time *= 1.5
                else:
                    break 
            except Exception as e:
                log(f"❌ Error: {e}")
                time.sleep(2)
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks."
    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
    if success_count == 0: return None, "Code block not found."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    """
    Surgical Critic: Instead of the whole file, send a DIFF.
    This prevents truncation and helps the AI focus on the change.
    """
    if original_code == new_code: return False, "No change detected."
    
    # Generate a unified diff
    diff = list(difflib.unified_diff(
        original_code.splitlines(keepends=True),
        new_code.splitlines(keepends=True),
        fromfile='original',
        tofile='patched',
        n=5 # Show 5 lines of context around changes
    ))
    diff_text = "".join(diff)

    prompt = f"""
    ROLE: Senior React QA Engineer.
    TASK: {task}
    
    Examine the DIFF (changes) below. 
    Does this change correctly implement the task without breaking React state?
    
    DIFF:
    {diff_text}
    
    OUTPUT: 'PASS' or 'FAIL: [Specific Reason]'
    """
    
    response = ask_gemini_v6_style(prompt, model_hint="critic")
    if not response: return True, "Critic silent, assuming pass."
    if "PASS" in response: return True, "Verified."
    return False, response.replace("FAIL:", "").strip()

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    critique_history = ""
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"Expert React Engineer. TASK: {task}\n{critique_history}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        response = ask_gemini_v6_style(prompt, model_hint="coder")
        if not response: continue
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch Error: {message}")
            critique_history = "PREVIOUS ATTEMPT FAILED: The SEARCH block was incorrect. Use EXACT code from the file."
            continue
        log("🕵️ Verifying Fix (Surgical Diff)...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        if is_valid:
            log(f"✅ QA Passed.")
            write_file("index.html", new_code)
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            repo.remotes.origin.push()
            log("🚀 Pushed.")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED PREVIOUS FIX: {feedback}"
    return True 

def run_loop():
    log("🤖 Jules SURGICAL (Diff-Mode) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v20_20260114_2139_074b9b6.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

# --- FORCE UNBUFFERED OUTPUT ---
def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

MODELS_TO_TRY = [
    "gemini-3-pro-preview",    
    "gemini-3-flash-preview", 
    "gemini-2.0-flash-exp"     
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except FileNotFoundError: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        if not response_json: return None
        candidates = response_json.get("candidates", [])
        if not candidates: return None
        candidate = candidates[0]
        content = candidate.get("content", {})
        parts = content.get("parts", [])
        full_text = "".join([p.get("text", "") for p in parts if "text" in p])
        return full_text if full_text.strip() else None
    except: return None

def ask_gemini_v6_style(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}, 
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        wait_time = 5
        for attempt in range(5): 
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/5)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: return text
                elif resp.status_code == 429:
                    log(f"⏳ Busy (429). Waiting {wait_time}s...")
                    time.sleep(wait_time)
                    wait_time *= 1.5
                else:
                    log(f"⚠️ Status {resp.status_code} from {model}")
                    break 
            except Exception as e:
                log(f"❌ Error hitting API: {e}")
                time.sleep(2)
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks."
    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
    if success_count == 0: return None, "Code block not found."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code: return False, "No change detected."
    
    diff = list(difflib.unified_diff(
        original_code.splitlines(keepends=True),
        new_code.splitlines(keepends=True),
        fromfile='original',
        tofile='patched',
        n=5 
    ))
    diff_text = "".join(diff)

    prompt = f"""
    ROLE: Senior React QA Engineer.
    TASK: {task}
    
    Examine the DIFF (changes) below. 
    Does this change correctly implement the task without breaking React state?
    
    DIFF:
    {diff_text}
    
    OUTPUT: 'PASS' or 'FAIL: [Specific Reason]'
    """
    
    response = ask_gemini_v6_style(prompt, model_hint="critic")
    if not response: return True, "Critic silent, assuming pass."
    if "PASS" in response: return True, "Verified."
    return False, response.replace("FAIL:", "").strip()

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    
    current_code = read_file("index.html")
    critique_history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"Expert React Engineer. TASK: {task}\n{critique_history}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        
        response = ask_gemini_v6_style(prompt, model_hint="coder")
        if not response: 
            log("❌ No response from AI.")
            continue
            
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch Error: {message}")
            critique_history = "PREVIOUS ATTEMPT FAILED: The SEARCH block was incorrect. Use EXACT code from the file."
            continue
            
        log(f"✅ Patch success: {message}")
        log("🕵️ Verifying Fix (Surgical Diff)...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        
        if is_valid:
            log(f"✅ QA Passed: {feedback}")
            log("💾 Saving to index.html...")
            write_file("index.html", new_code)
            
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            
            log("🚀 Pushing to GitHub...")
            repo.remotes.origin.push()
            log(f"🎉 SUCCESS! {task} is live.")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED PREVIOUS FIX: {feedback}"
            
    return True 

def run_loop():
    log("🤖 Jules SURGICAL (LOUD MODE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): 
            log("⏰ Time limit reached.")
            break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v21_20260114_2144_655f03c.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"

MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

MODELS_TO_TRY = [
    "gemini-3-pro-preview",    
    "gemini-3-flash-preview", 
    "gemini-2.0-flash-exp"     
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except FileNotFoundError: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        if not response_json: return None
        candidates = response_json.get("candidates", [])
        if not candidates: return None
        candidate = candidates[0]
        content = candidate.get("content", {})
        parts = content.get("parts", [])
        full_text = "".join([p.get("text", "") for p in parts if "text" in p])
        return full_text if full_text.strip() else None
    except: return None

def ask_gemini_v6_style(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}, 
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        wait_time = 5
        for attempt in range(5): 
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/5)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: return text
                elif resp.status_code == 429:
                    log(f"⏳ Busy (429). Waiting {wait_time}s...")
                    time.sleep(wait_time)
                    wait_time *= 1.5
                else:
                    log(f"⚠️ Status {resp.status_code} from {model}")
                    break 
            except Exception as e:
                log(f"❌ Error hitting API: {e}")
                time.sleep(2)
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found in AI response."
    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
    if success_count == 0: return None, "SEARCH block content did not match anything in index.html."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code: return False, "No change detected."
    diff = list(difflib.unified_diff(original_code.splitlines(keepends=True), new_code.splitlines(keepends=True), fromfile='original', tofile='patched', n=5))
    diff_text = "".join(diff)
    prompt = f"ROLE: Senior React QA Engineer. TASK: {task}\nDIFF:\n{diff_text}\nOUTPUT: 'PASS' or 'FAIL: [Reason]'"
    response = ask_gemini_v6_style(prompt, model_hint="critic")
    if not response: return True, "Critic silent, assuming pass."
    if "PASS" in response: return True, "Verified."
    return False, response.replace("FAIL:", "").strip()

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    critique_history = ""
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"Expert React Engineer. TASK: {task}\n{critique_history}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        response = ask_gemini_v6_style(prompt, model_hint="coder")
        if not response: 
            log("❌ No response from AI.")
            continue
        
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch Error: {message}")
            log(f"📄 [DEBUG] AI provided this invalid response:\n{response[:500]}...") # Print first 500 chars of failure
            critique_history = f"PREVIOUS ATTEMPT FAILED: {message}. Ensure the SEARCH block matches index.html EXACTLY."
            continue
            
        log(f"✅ Patch success: {message}")
        log("🕵️ Verifying Fix...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        if is_valid:
            log(f"✅ QA Passed. Saving and Pushing...")
            write_file("index.html", new_code)
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            repo.remotes.origin.push()
            log("🚀 Pushed to GitHub.")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED PREVIOUS FIX: {feedback}"
    return True 

def run_loop():
    log("🤖 Jules SURGICAL (LOUD MODE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v22_20260114_2150_ad6c454.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

MODELS_TO_TRY = ["gemini-3-pro-preview", "gemini-3-flash-preview", "gemini-2.0-flash-exp"]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def ask_gemini_v6_style(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}], "generationConfig": {"temperature": 0.1}}
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        for attempt in range(5): 
            log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/5)...")
            try:
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    res_json = resp.json()
                    # LOG THE RAW RESPONSE IMMEDIATELY
                    text = res_json['candidates'][0]['content']['parts'][0]['text']
                    log(f"📥 [RAW RESPONSE RECEIVED] Length: {len(text)} chars")
                    return text
                log(f"⚠️ API Status: {resp.status_code}")
            except Exception as e:
                log(f"❌ API Error: {e}")
            time.sleep(2)
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: 
        log("🔍 [DEBUG] No markers found. AI Response starts with: " + patch_text[:100])
        return None, "No valid SEARCH/REPLACE blocks."
    
    new_code = original_code
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            log("✅ Found exact match for search block.")
        else:
            log("❌ FAILED TO MATCH SEARCH BLOCK. First 50 chars of search: " + search_block[:50].replace('\n', ' '))
            return None, "Search block mismatch."
    return new_code, "Success"

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"TASK: {task}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        
        response = ask_gemini_v6_style(prompt)
        if not response: continue
        
        new_code, msg = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch Error: {msg}")
            continue
            
        log("✅ Patch Applied. Saving...")
        write_file("index.html", new_code)
        # Git Push logic omitted for brevity in logs but present in your script
        return True
    return False

log("🤖 Jules SURGICAL (ULTRA LOUD) Started...")
process_single_task()


================================================================================
=== FILE: v23_20260114_2201_7ae9260.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

# Retains original self-correction depth
MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

# Force unbuffered output for GitHub Actions visibility
def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# MASTER HIERARCHY: Prioritizes Gemini 3 for reasoning, fallbacks to reliable 2.0
MODELS_TO_TRY = [
    "gemini-3-pro-preview",   # Mastermind for complex patches
    "gemini-3-flash-preview", # Fast Mastermind
    "gemini-2.0-flash-exp",   # Best current balance
    "gemini-1.5-pro"          # Final reliable backup
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        parts = response_json['candidates'][0]['content']['parts']
        return "".join([p.get("text", "") for p in parts])
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1},
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        for attempt in range(3):
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/3)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: 
                        log(f"📥 [RESPONSE RECEIVED] Length: {len(text)} chars")
                        return text
                elif resp.status_code == 429:
                    log(f"⏳ Rate Limit on {model}. Waiting...")
                    time.sleep(5)
            except Exception as e:
                log(f"❌ Error: {e}")
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
            log("✅ Found exact match for block.")
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            log("✅ Found whitespace-stripped match.")
        else:
            log(f"❌ MISMATCH: Could not find block starting with: {search_block[:50]}...")
            
    if success_count == 0: return None, "No blocks matched."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code: return False, "No changes detected."
    diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
    
    prompt = f"TASK: {task}\nDIFF:\n{diff}\nDoes this fix the task without breaking React? Respond 'PASS' or 'FAIL: [reason]'"
    response = ask_gemini_robust(prompt, model_hint="critic")
    if not response: return True, "Critic silent."
    return ("PASS" in response.upper()), response

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    critique_history = ""

    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"Expert React Dev. TASK: {task}\n{critique_history}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        
        response = ask_gemini_robust(prompt)
        if not response: continue
        
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch failed: {message}")
            critique_history = f"PREVIOUS FAIL: {message}. Ensure SEARCH block is exact."
            continue

        log("🕵️ Verifying Logic...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        if is_valid:
            log("✅ QA Passed. Saving...")
            write_file("index.html", new_code)
            
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            repo.remotes.origin.push()
            log("🚀 Pushed to GitHub.")
            
            if wait_for_render_deploy(): log("🎉 Deploy Success!")
            else: log("🚨 Deploy Failed on Render.")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED: {feedback}"
    return True

def run_loop():
    log("🤖 Jules Level 9 (MASTER RESTORE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(10)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v24_20260115_1707_6708dc9.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

# Retains original self-correction depth
MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

# Force unbuffered output for GitHub Actions visibility
def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# MASTER HIERARCHY: Prioritizes Gemini 3 for reasoning, fallbacks to reliable 2.0
MODELS_TO_TRY = [
    "gemini-3-pro-preview",   # Mastermind for complex patches
    "gemini-3-flash-preview", # Fast Mastermind
    "gemini-2.0-flash-exp",   # Best current balance
    "gemini-1.5-pro"          # Final reliable backup
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        parts = response_json['candidates'][0]['content']['parts']
        return "".join([p.get("text", "") for p in parts])
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1},
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        for attempt in range(3):
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/3)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: 
                        log(f"📥 [RESPONSE RECEIVED] Length: {len(text)} chars")
                        return text
                elif resp.status_code == 429:
                    log(f"⏳ Rate Limit on {model}. Waiting...")
                    time.sleep(5)
            except Exception as e:
                log(f"❌ Error: {e}")
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
            log("✅ Found exact match for block.")
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            log("✅ Found whitespace-stripped match.")
        else:
            log(f"❌ MISMATCH: Could not find block starting with: {search_block[:50]}...")
            
    if success_count == 0: return None, "No blocks matched."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code: return False, "No changes detected."
    diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
    
    prompt = f"TASK: {task}\nDIFF:\n{diff}\nDoes this fix the task without breaking React? Respond 'PASS' or 'FAIL: [reason]'"
    response = ask_gemini_robust(prompt, model_hint="critic")
    if not response: return True, "Critic silent."
    return ("PASS" in response.upper()), response

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    critique_history = ""

    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"Expert React Dev. TASK: {task}\n{critique_history}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        
        response = ask_gemini_robust(prompt)
        if not response: continue
        
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch failed: {message}")
            critique_history = f"PREVIOUS FAIL: {message}. Ensure SEARCH block is exact."
            continue

        log("🕵️ Verifying Logic...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        if is_valid:
            log("✅ QA Passed. Saving...")
            write_file("index.html", new_code)
            
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            repo.remotes.origin.push()
            log("🚀 Pushed to GitHub.")
            
            if wait_for_render_deploy(): log("🎉 Deploy Success!")
            else: log("🚨 Deploy Failed on Render.")
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED: {feedback}"
    return True

def run_loop():
    log("🤖 Jules Level 9 (MASTER RESTORE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): 
            log("✅ No more tasks.")
            break
        time.sleep(10)

if __name__ == "__main__":
    run_loop()



================================================================================
=== FILE: v25_20260115_1727_02b9237.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

MODELS_TO_TRY = [
    "gemini-3-pro-preview",
    "gemini-3-flash-preview",
    "gemini-2.0-flash-exp",
    "gemini-1.5-pro"
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        parts = response_json['candidates'][0]['content']['parts']
        return "".join([p.get("text", "") for p in parts])
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1},
    }
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        for attempt in range(3):
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/3)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: return text
                elif resp.status_code == 429:
                    time.sleep(5)
            except Exception as e:
                log(f"❌ Error: {e}")
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."
    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
    if success_count == 0: return None, "No blocks matched."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code: return False, "No changes."
    diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
    prompt = f"TASK: {task}\nDIFF:\n{diff}\nRespond 'PASS' or 'FAIL: [reason]'"
    response = ask_gemini_robust(prompt, model_hint="critic")
    return ("PASS" in (response or "").upper()), response

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Render Status: {status}")
                if status == "live": return True
                if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    critique_history = ""
    for attempt in range(MAX_QA_RETRIES):
        prompt = f"Expert React Dev. TASK: {task}\n{critique_history}\nCODE:\n{current_code}"
        response = ask_gemini_robust(prompt)
        if not response: continue
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            critique_history = f"PREVIOUS FAIL: {message}"
            continue
        is_valid, feedback = verify_fix(task, current_code, new_code)
        if is_valid:
            write_file("index.html", new_code)
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            
            # --- CRITICAL FIX: AGGRESSIVE SYNC BEFORE PUSH ---
            try:
                log("🔄 Pulling latest to clear race conditions...")
                repo.remotes.origin.pull(rebase=True)
                repo.remotes.origin.push()
                log("🚀 Pushed to GitHub.")
            except Exception as e:
                log(f"⚠️ Sync failed: {e}")
                return False
            
            wait_for_render_deploy()
            return True
    return True

def run_loop():
    log("🤖 Jules Level 9 (MASTER RESTORE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): break
        time.sleep(10)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v26_20260115_1803_94d0be8.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# UPDATED HIERARCHY: Removed 1.5 models, focusing on 2.0 Flash and 3.0 Pro
MODELS_TO_TRY = [
    "gemini-2.0-flash-exp",   # Primary: Fast & Reliable
    "gemini-3-pro-preview"    # Secondary: Deep Reasoning
]

def read_file(filename):
    with open(filename, 'r', encoding='utf-8') as f: return f.read()

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def extract_text_from_response(response_json):
    try:
        parts = response_json['candidates'][0]['content']['parts']
        return "".join([p.get("text", "") for p in parts])
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1},
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        for attempt in range(3):
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/3)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                
                # --- ROBUST ERROR LOGGING (Preserved) ---
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: 
                        log(f"📥 [200 OK] Response received: {len(text)} chars")
                        return text
                elif resp.status_code == 429:
                    log(f"⏳ [429 Rate Limit] Waiting 10s...")
                    time.sleep(10)
                else:
                    log(f"❌ [API Error {resp.status_code}] {resp.text[:200]}...")
                    
            except Exception as e:
                log(f"❌ [Exception]: {e}")
                
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            
    if success_count == 0: return None, "No blocks matched."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code):
    if original_code == new_code: return False, "No changes detected."
    diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
    
    prompt = f"TASK: {task}\nDIFF:\n{diff}\nRespond 'PASS' or 'FAIL: [reason]'"
    response = ask_gemini_robust(prompt, model_hint="critic")
    return ("PASS" in (response or "").upper()), response

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    current_code = read_file("index.html")
    critique_history = ""

    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        prompt = f"Expert React Dev. TASK: {task}\n{critique_history}\nFORMAT: <<<<<<< SEARCH\n(old)\n=======\n(new)\n>>>>>>> REPLACE\n\nCODE:\n{current_code}"
        
        response = ask_gemini_robust(prompt)
        if not response: continue
        
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch failed: {message}")
            critique_history = f"PREVIOUS FAIL: {message}"
            continue

        log("🕵️ Verifying Logic...")
        is_valid, feedback = verify_fix(task, current_code, new_code)
        if is_valid:
            log("✅ QA Passed. Saving...")
            write_file("index.html", new_code)
            
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            
            try:
                log("🔄 Pulling latest changes before push...")
                repo.remotes.origin.pull(rebase=True)
                repo.remotes.origin.push()
                log("🚀 Pushed to GitHub.")
            except Exception as e:
                log(f"⚠️ Push failed: {e}")
                return False
            
            wait_for_render_deploy()
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            critique_history = f"QA REJECTED: {feedback}"
    return True

def run_loop():
    log("🤖 Jules Level 10 (DEBUG MODE) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): 
            log("✅ No more tasks or sync error.")
            break
        time.sleep(10)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v27_20260115_1821_a74d42d.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

MAX_QA_RETRIES = 3 
MAX_RUNTIME_MINUTES = 45
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# HIERARCHY: Try 3.0 Pro first (Reasoning), fallback to 2.0 Flash (Speed)
MODELS_TO_TRY = [
    "gemini-3-pro-preview",   # Primary: Advanced Reasoning
    "gemini-2.0-flash-exp"    # Fallback: Fast & Reliable
]

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except FileNotFoundError:
        return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- SYSTEM CONTEXT LOADER (RAG) ---
def get_system_context():
    """Reads architectural rules to enforce the Jules persona."""
    context_buffer = ""
    # Critical documentation files
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    
    for doc in doc_files:
        content = read_file(doc)
        if content:
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
            log(f"🧠 Loaded context from {doc}")
    
    if not context_buffer:
        log("⚠️ No system documentation found. Jules is using raw logic.")
    
    return context_buffer

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def mark_task_failed(task_name, reason):
    log(f"⚠️ Moving failed task to bottom: {task_name}")
    content = read_file("BACKLOG.md")
    task_line = f"- [ ] **{task_name}**"
    if task_line in content:
        content = content.replace(task_line, "").strip()
        footer = f"\n\n- [ ] **{task_name}** (Retry: {reason})"
        write_file("BACKLOG.md", content + footer)

def extract_text_from_response(response_json):
    try:
        parts = response_json['candidates'][0]['content']['parts']
        return "".join([p.get("text", "") for p in parts])
    except: return None

def ask_gemini_robust(prompt, model_hint="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1},
    }
    
    for model in MODELS_TO_TRY:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        for attempt in range(3):
            try:
                log(f"🔄 [{model_hint.upper()}] {model} (Attempt {attempt+1}/3)...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                
                # --- ROBUST LOGGING ---
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: 
                        log(f"📥 [200 OK] Response received: {len(text)} chars")
                        return text
                elif resp.status_code == 429:
                    log(f"⏳ [429 Rate Limit] Waiting 10s...")
                    time.sleep(10)
                else:
                    log(f"❌ [API Error {resp.status_code}] {resp.text[:200]}...")
            except Exception as e:
                log(f"❌ [Exception]: {e}")
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
            log("✅ Found exact match.")
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            log("✅ Found whitespace-stripped match.")
            
    if success_count == 0: return None, "No blocks matched."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code, context):
    if original_code == new_code: return False, "No changes detected."
    diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
    
    # Inject System Context into Critic as well
    prompt = f"{context}\n\nROLE: You are the Critic defined in AGENTS.md.\nTASK: {task}\nDIFF:\n{diff}\n\nDoes this fix the task without breaking React state immutability or the Index.html structure? Respond 'PASS' or 'FAIL: [reason]'"
    response = ask_gemini_robust(prompt, model_hint="critic")
    return ("PASS" in (response or "").upper()), response

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    
    # 1. Load System Context (RAG)
    system_context = get_system_context()
    current_code = read_file("index.html")
    critique_history = ""
    last_error = "Unknown"

    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        
        # 2. Inject Context into Prompt
        prompt = f"""
{system_context}

---
CURRENT MISSION:
You are acting as the Agent 'Jules'. 
Your goal is to implement the following task in 'index.html' while strictly adhering to the architectural rules above.

TASK: {task}
CRITIQUE HISTORY: {critique_history}

RESPONSE FORMAT:
Strictly use the SEARCH/REPLACE block format defined in ARCHITECTURE.md (if applicable) or standard Git conflict markers:
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE

CODE CONTEXT:
{current_code}
"""
        response = ask_gemini_robust(prompt)
        if not response: continue
        
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch failed: {message}")
            last_error = message
            critique_history = f"PREVIOUS FAIL: {message}. Ensure SEARCH block matches exact whitespace."
            continue

        log("🕵️ Verifying Logic...")
        # 3. Pass Context to Critic
        is_valid, feedback = verify_fix(task, current_code, new_code, system_context)
        if is_valid:
            log("✅ QA Passed. Saving...")
            write_file("index.html", new_code)
            
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            
            # --- AGGRESSIVE SYNC ---
            try:
                log("🔄 Pulling latest changes before push...")
                repo.remotes.origin.pull(rebase=True)
                repo.remotes.origin.push()
                log("🚀 Pushed to GitHub.")
            except Exception as e:
                log(f"⚠️ Push failed: {e}")
                return False
            
            wait_for_render_deploy()
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            last_error = feedback
            critique_history = f"QA REJECTED: {feedback}"
            
    # Fail-Forward
    mark_task_failed(task, last_error)
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"fix: skip stuck task {task}")
    repo.remotes.origin.push()
    return True

def run_loop():
    log("🤖 Jules Level 11 (HYBRID MASTER) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): 
            log("✅ No more tasks or sync error.")
            break
        time.sleep(10)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v28_20260116_0823_d51ec29.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = "srv-d5jlon15pdvs739hp3jg"
SITE_URL = "https://tytax-elite.onrender.com"

# INCREASED RETRIES: We have more models, so we can try more times.
MAX_QA_RETRIES = 4 
MAX_RUNTIME_MINUTES = 60
START_TIME = time.time()

def log(message):
    print(message, flush=True)

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY missing!")

# --- THE NEW MULTI-LANE BRAIN ---
# Lane 1: The Architect (Complex Logic)
# Lane 2: The Engineer (Fast Coding)
# Lane 3: The Critic (Review Only)

CODER_MODELS = [
    "gemini-3-pro-preview",    # 1. Primary Genius
    "gemini-3-flash",          # 2. Smart & Fast (New 3.0 Model)
    "gemini-2.5-flash",        # 3. Backup Workhorse
    "gemini-2.0-flash"         # 4. Last Resort
]

CRITIC_MODELS = [
    "gemini-2.5-pro",          # 1. The Expert Reviewer (Unused Quota)
    "gemini-2.0-flash"         # 2. Fast Check
]

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except FileNotFoundError:
        return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- SYSTEM CONTEXT LOADER (RAG) ---
def get_system_context():
    context_buffer = ""
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    for doc in doc_files:
        content = read_file(doc)
        if content:
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
            log(f"🧠 Loaded context from {doc}")
    return context_buffer

def get_next_task():
    try:
        content = read_file("BACKLOG.md")
        match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
        return match.group(1).strip() if match else None
    except: return None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def mark_task_failed(task_name, reason):
    log(f"⚠️ Moving failed task to bottom: {task_name}")
    content = read_file("BACKLOG.md")
    task_line = f"- [ ] **{task_name}**"
    if task_line in content:
        content = content.replace(task_line, "").strip()
        footer = f"\n\n- [ ] **{task_name}** (Retry: {reason})"
        write_file("BACKLOG.md", content + footer)

def extract_text_from_response(response_json):
    try:
        parts = response_json['candidates'][0]['content']['parts']
        return "".join([p.get("text", "") for p in parts])
    except: return None

def ask_gemini_robust(prompt, role="coder"):
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1},
    }
    
    # INTELLIGENT ROUTING: Pick the right list based on the job
    models_to_use = CRITIC_MODELS if role == "critic" else CODER_MODELS
    
    for model in models_to_use:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        # Only try each model twice to fail-over quickly
        for attempt in range(2): 
            try:
                log(f"🔄 [{role.upper()}] {model} (Attempt {attempt+1})...")
                resp = requests.post(url, headers=headers, data=json.dumps(data))
                
                if resp.status_code == 200:
                    text = extract_text_from_response(resp.json())
                    if text: 
                        log(f"📥 [200 OK] Response received: {len(text)} chars")
                        return text
                elif resp.status_code == 429:
                    log(f"⏳ [429 Rate Limit] Switching to next model...")
                    time.sleep(2) 
                    break # Break inner loop -> Go to next model in list
                else:
                    log(f"❌ [API Error {resp.status_code}] {resp.text[:200]}...")
            except Exception as e:
                log(f"❌ [Exception]: {e}")
    return None

def apply_patch(original_code, patch_text):
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch_text, re.DOTALL)
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."

    new_code = original_code
    success_count = 0
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            success_count += 1
            log("✅ Found exact match.")
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            success_count += 1
            log("✅ Found whitespace-stripped match.")
            
    if success_count == 0: return None, "No blocks matched."
    return new_code, f"Applied {success_count} patches."

def verify_fix(task, original_code, new_code, context):
    if original_code == new_code: return False, "No changes detected."
    diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
    
    prompt = f"{context}\n\nROLE: You are the Critic defined in AGENTS.md.\nTASK: {task}\nDIFF:\n{diff}\n\nDoes this fix the task without breaking React state immutability or the Index.html structure? Respond 'PASS' or 'FAIL: [reason]'"
    # ROUTING: Explicitly ask the 'critic' models
    response = ask_gemini_robust(prompt, role="critic")
    return ("PASS" in (response or "").upper()), response

def wait_for_render_deploy():
    if not RENDER_API_KEY: return True
    log("🚀 Monitoring Render Deployment...")
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    
    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

def process_single_task():
    task = get_next_task()
    if not task: return False
    log(f"\n📋 TARGET: {task}")
    
    system_context = get_system_context()
    current_code = read_file("index.html")
    critique_history = ""
    last_error = "Unknown"

    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Coder Attempt {attempt + 1}/{MAX_QA_RETRIES}...")
        
        prompt = f"""
{system_context}

---
CURRENT MISSION:
You are acting as the Agent 'Jules'. 
Your goal is to implement the following task in 'index.html' while strictly adhering to the architectural rules above.

TASK: {task}
CRITIQUE HISTORY: {critique_history}

RESPONSE FORMAT:
Strictly use the SEARCH/REPLACE block format defined in ARCHITECTURE.md.
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE

CODE CONTEXT:
{current_code}
"""
        # ROUTING: Explicitly ask the 'coder' models
        response = ask_gemini_robust(prompt, role="coder")
        if not response: continue
        
        new_code, message = apply_patch(current_code, response)
        if not new_code:
            log(f"❌ Patch failed: {message}")
            last_error = message
            critique_history = f"PREVIOUS FAIL: {message}. Ensure SEARCH block matches exact whitespace."
            continue

        log("🕵️ Verifying Logic...")
        is_valid, feedback = verify_fix(task, current_code, new_code, system_context)
        if is_valid:
            log("✅ QA Passed. Saving...")
            write_file("index.html", new_code)
            
            repo = git.Repo(REPO_PATH)
            repo.git.add(all=True)
            repo.index.commit(f"feat(jules): {task}")
            mark_task_done(task)
            repo.git.add("BACKLOG.md")
            repo.index.commit(f"docs: marked {task} as done")
            
            try:
                log("🔄 Pulling latest changes before push...")
                repo.remotes.origin.pull(rebase=True)
                repo.remotes.origin.push()
                log("🚀 Pushed to GitHub.")
            except Exception as e:
                log(f"⚠️ Push failed: {e}")
                return False
            
            wait_for_render_deploy()
            return True
        else:
            log(f"❌ QA Failed: {feedback}")
            last_error = feedback
            critique_history = f"QA REJECTED: {feedback}"
            
    mark_task_failed(task, last_error)
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit(f"fix: skip stuck task {task}")
    repo.remotes.origin.push()
    return True

def run_loop():
    log("🤖 Jules Level 12 (MULTI-MODEL SWARM) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > (MAX_RUNTIME_MINUTES - 5): break
        if not process_single_task(): 
            log("✅ No more tasks or sync error.")
            break
        time.sleep(5)

if __name__ == "__main__":
    run_loop()


================================================================================
=== FILE: v29_20260116_0841_2519d44.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- CONFIGURATION & ENV ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")
SITE_URL = os.environ.get("SITE_URL", "https://tytax-elite.onrender.com")

# DRY RUN: If set to '1', disables Git Push and Render checks
DRY_RUN = os.environ.get("DRY_RUN", "0") == "1"

# Timing & Retries
MAX_QA_RETRIES = int(os.environ.get("MAX_QA_RETRIES", 4))
MAX_RUNTIME_MINUTES = int(os.environ.get("MAX_RUNTIME_MINUTES", 60))
REQUEST_TIMEOUT = 60  # seconds

# Model Configuration
def get_model_list(env_var, defaults):
    val = os.environ.get(env_var)
    if val:
        return [m.strip() for m in val.split(",") if m.strip()]
    return defaults

# UPDATED: Use known working models first to save time, but keep 3.0 preview as first option if available.
CODER_MODELS = get_model_list("JULES_CODER_MODELS", [
    "gemini-2.0-flash",        # 1. The Speed Demon (Proven working)
    "gemini-2.0-flash-exp",    # 2. Reliable Backup
    "gemini-1.5-flash",        # 3. Old Reliable
    "gemini-3-pro-preview"     # 4. Break Glass (Smarter but limited)
])

CRITIC_MODELS = get_model_list("JULES_CRITIC_MODELS", [
    "gemini-1.5-pro",          # 1. High Intelligence Reviewer
    "gemini-2.0-flash"         # 2. Fast Check
])

# Generation Configs
CODER_CONFIG = {"maxOutputTokens": 8192, "temperature": 0.1}
CRITIC_CONFIG = {"maxOutputTokens": 1024, "temperature": 0.0}

# Global State
START_TIME = time.time()
UNAVAILABLE_MODELS = set() # Tracks models that returned 404

def log(message):
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"[{timestamp}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

# --- UTILS ---

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except FileNotFoundError:
        return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def truncate_content(content, max_chars=12000):
    """Truncates large context to save TPM, keeping head and tail."""
    if len(content) <= max_chars:
        return content
    half = max_chars // 2
    return content[:half] + "\n\n... [TRUNCATED SYSTEM CONTEXT] ...\n\n" + content[-half:]

def get_system_context():
    context_buffer = ""
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    
    for doc in doc_files:
        content = read_file(doc)
        if content:
            content = truncate_content(content)
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
    
    total_len = len(context_buffer)
    log(f"🧠 Loaded System Context (~{total_len} chars)")
    return context_buffer

# --- GEMINI API ENGINE ---

def extract_text_from_response(response_json):
    try:
        if 'candidates' in response_json and response_json['candidates']:
            parts = response_json['candidates'][0]['content']['parts']
            return "".join([p.get("text", "") for p in parts])
    except (KeyError, IndexError, TypeError) as e:
        log(f"⚠️ Failed to extract text from JSON: {e}")
    return None

def call_gemini_api(model, prompt, generation_config):
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": generation_config
    }

    try:
        response = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
    except requests.exceptions.RequestException as e:
        log(f"❌ Network Error ({model}): {e}")
        return None, 0 

    return response.json(), response.status_code

def ask_gemini_swarm(prompt, role="coder"):
    models = CODER_MODELS if role == "coder" else CRITIC_MODELS
    config = CODER_CONFIG if role == "coder" else CRITIC_CONFIG
    
    for model in models:
        if model in UNAVAILABLE_MODELS:
            continue 

        max_retries = 2
        for attempt in range(max_retries + 1):
            log(f"🔄 [{role.upper()}] {model} (Attempt {attempt+1})...")
            
            response_json, status_code = call_gemini_api(model, prompt, config)

            if status_code == 200:
                text = extract_text_from_response(response_json)
                if text:
                    return text
                else:
                    log(f"⚠️ Empty response from {model}")
                    break 
            
            elif status_code == 429:
                log(f"⏳ 429 Rate Limit on {model}")
                sleep_time = 2 * (2 ** attempt) + random.uniform(0, 1)
                if attempt < max_retries:
                    log(f"   Sleeping {sleep_time:.2f}s...")
                    time.sleep(sleep_time)
                else:
                    log(f"   Skipping {model} due to persistent 429.")
            
            elif status_code == 404:
                log(f"🚫 Model Not Found: {model}. Marking unavailable.")
                UNAVAILABLE_MODELS.add(model)
                break 
            
            elif status_code >= 500:
                log(f"💥 Server Error {status_code} on {model}")
                if attempt < max_retries:
                    time.sleep(2)
                else:
                    break
            else:
                log(f"❌ API Error {status_code}: {response_json}")
                break 

    log(f"❌ All models failed for role: {role}")
    return None

# --- PATCH ENGINE ---

def robust_fuzzy_replace(original, search_block, replace_block):
    # 1. Exact Match
    if search_block in original:
        log("✅ Patch Method: Exact Match")
        return original.replace(search_block, replace_block), True

    # 2. Strip Match
    if search_block.strip() in original:
        log("✅ Patch Method: Whitespace Strip Match")
        return original.replace(search_block.strip(), replace_block), True

    # 3. Fuzzy Match
    log("⚠️ Exact match failed. Attempting Fuzzy Match...")
    matcher = difflib.SequenceMatcher(None, original, search_block)
    match = matcher.find_longest_match(0, len(original), 0, len(search_block))
    
    if match.size > 0:
        found_block = original[match.a : match.a + match.size]
        ratio = difflib.SequenceMatcher(None, found_block, search_block).ratio()
        log(f"   Fuzzy Score: {ratio:.4f}")
        
        if ratio >= 0.88:
            log("✅ Patch Method: Fuzzy Match Accepted")
            new_code = original[:match.a] + replace_block + original[match.a + match.size:]
            return new_code, True
        else:
            log(f"❌ Fuzzy match score too low ({ratio:.4f} < 0.88)")
    
    return original, False

def apply_patches(original_code, response_text):
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, response_text, re.DOTALL)
    
    if not matches:
        return None, "No valid SEARCH/REPLACE blocks found in response."

    current_code = original_code
    applied_count = 0
    
    for search_block, replace_block in matches:
        new_code, success = robust_fuzzy_replace(current_code, search_block, replace_block)
        if success:
            current_code = new_code
            applied_count += 1
        else:
            return None, f"Failed to match block:\n{search_block[:50]}..."

    if current_code == original_code:
        return None, "Resulting code is identical to original."
    
    if "<!DOCTYPE html>" not in current_code and "<html" not in current_code:
        return None, "CRITICAL: Patch removed root HTML tags. Reverting."

    return current_code, f"Successfully applied {applied_count} patches."

# --- GIT & TASK MANAGEMENT ---

def get_next_task():
    content = read_file("BACKLOG.md")
    if not content: return None
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def mark_task_failed(task_name, reason):
    log(f"⚠️ Moving failed task to bottom: {task_name}")
    content = read_file("BACKLOG.md")
    task_line = f"- [ ] **{task_name}**"
    if task_line in content:
        content = content.replace(task_line, "").strip()
        footer = f"\n\n- [ ] **{task_name}** (Retry: {reason})"
        write_file("BACKLOG.md", content + footer)

def git_operations(task_name):
    if DRY_RUN:
        log("🐢 DRY RUN: Skipping Git Push & Render Check")
        return True

    try:
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        if not repo.index.diff("HEAD"):
            log("⚠️ No git changes to commit.")
            return True
            
        repo.index.commit(f"feat(jules): {task_name}")
        
        log("🔄 Pulling latest changes...")
        repo.remotes.origin.pull(rebase=True)
        
        log("🚀 Pushing to GitHub...")
        repo.remotes.origin.push()
        return True
    except Exception as e:
        log(f"❌ Git Error: {e}")
        return False

def check_render_deploy():
    if DRY_RUN or not RENDER_API_KEY or not RENDER_SERVICE_ID:
        return True
    
    log("🚀 Monitoring Render Deployment...")
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}

    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except Exception as e:
            log(f"⚠️ Render API check failed: {e}")
        time.sleep(15)
    
    log("⚠️ Render timed out (assuming success to continue loop)")
    return True

# --- MAIN LOOP ---

def process_single_task():
    task = get_next_task()
    if not task:
        log("✅ No pending tasks found in BACKLOG.md")
        return False
    
    log(f"\n📋 TARGET: {task}")
    
    system_context = get_system_context()
    original_code = read_file("index.html")
    critique_history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt + 1}/{MAX_QA_RETRIES}...")

        prompt = f"""
{system_context}
---
TASK: {task}
CRITIQUE HISTORY: {critique_history}

INSTRUCTIONS:
- You are the 'Jules' Coder Agent.
- Modify 'index.html' to satisfy the task.
- STRICTLY return code changes in SEARCH/REPLACE blocks.
- Do NOT return the full file unless necessary.
- NO conversational text outside the blocks.

FORMAT:
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE

CODE CONTEXT:
{original_code}
"""
        response_text = ask_gemini_swarm(prompt, role="coder")
        if not response_text:
            log("❌ Coder produced no output.")
            continue

        new_code, patch_msg = apply_patches(original_code, response_text)
        if not new_code:
            log(f"❌ Patch Failed: {patch_msg}")
            critique_history = f"PATCH ERROR: {patch_msg}. Please ensure SEARCH block matches existing code EXACTLY."
            continue
        
        log("🕵️ Critic Reviewing...")
        diff = "".join(difflib.unified_diff(
            original_code.splitlines(True), 
            new_code.splitlines(True), 
            n=3
        ))
        
        critic_prompt = f"""
{truncate_content(system_context, 4000)}
---
ROLE: Critic.
TASK: {task}
DIFF:
{diff}

INSTRUCTIONS:
- Analyze the diff. Does it solve the task?
- Check for syntax errors or architecture violations.
- Reply STRICTLY with:
  "PASS" 
  OR 
  "FAIL: <short reason>"
"""
        critic_response = ask_gemini_swarm(critic_prompt, role="critic")
        
        if critic_response and "PASS" in critic_response.upper() and "FAIL" not in critic_response.upper():
            log("✅ Critic PASSED.")
            write_file("index.html", new_code)
            
            mark_task_done(task)
            if git_operations(task):
                check_render_deploy()
            return True
        else:
            reason = critic_response if critic_response else "No response from critic"
            log(f"❌ Critic FAILED: {reason}")
            critique_history = f"CRITIC REJECTED: {reason}"

    mark_task_failed(task, "Max retries exhausted or Patch/Critic failed.")
    git_operations(f"skip stuck task {task}")
    return True

def run():
    log("🤖 Jules 'Multi-Model Swarm' Level 14 Started...")
    while True:
        elapsed = (time.time() - START_TIME) / 60
        if elapsed > MAX_RUNTIME_MINUTES:
            log("⏰ Max runtime reached. Exiting.")
            break
            
        if not process_single_task():
            break
            
        time.sleep(5)

if __name__ == "__main__":
    run()


================================================================================
=== FILE: v30_20260116_0846_591f34d.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- CONFIGURATION & ENV ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")
SITE_URL = os.environ.get("SITE_URL", "https://tytax-elite.onrender.com")

# DRY RUN: If set to '1', disables Git Push and Render checks
DRY_RUN = os.environ.get("DRY_RUN", "0") == "1"

# Timing & Retries
MAX_QA_RETRIES = int(os.environ.get("MAX_QA_RETRIES", 4))
MAX_RUNTIME_MINUTES = int(os.environ.get("MAX_RUNTIME_MINUTES", 60))
REQUEST_TIMEOUT = 60  
COOL_DOWN_SECONDS = 5 # Force a breather between heavy requests

# Model Configuration
def get_model_list(env_var, defaults):
    val = os.environ.get(env_var)
    if val:
        return [m.strip() for m in val.split(",") if m.strip()]
    return defaults

# UPDATED: Fixed 404s by using '-latest' and reordered for stability
CODER_MODELS = get_model_list("JULES_CODER_MODELS", [
    "gemini-2.0-flash",        # 1. Primary
    "gemini-1.5-flash-latest", # 2. Fixed Name (was 404ing)
    "gemini-2.0-flash-exp",    # 3. Fallback
    "gemini-3-pro-preview"     # 4. Emergency Only
])

CRITIC_MODELS = get_model_list("JULES_CRITIC_MODELS", [
    "gemini-1.5-pro-latest",   # 1. Fixed Name
    "gemini-2.0-flash"         # 2. Fast Check
])

# Generation Configs
CODER_CONFIG = {"maxOutputTokens": 8192, "temperature": 0.1}
CRITIC_CONFIG = {"maxOutputTokens": 1024, "temperature": 0.0}

# Global State
START_TIME = time.time()
UNAVAILABLE_MODELS = set() 

def log(message):
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"[{timestamp}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

# --- UTILS ---

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except FileNotFoundError:
        return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def truncate_content(content, max_chars=12000):
    if len(content) <= max_chars: return content
    half = max_chars // 2
    return content[:half] + "\n\n... [TRUNCATED SYSTEM CONTEXT] ...\n\n" + content[-half:]

def get_system_context():
    context_buffer = ""
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    for doc in doc_files:
        content = read_file(doc)
        if content:
            content = truncate_content(content)
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
    total_len = len(context_buffer)
    log(f"🧠 Loaded System Context (~{total_len} chars)")
    return context_buffer

# --- GEMINI API ENGINE ---

def extract_text_from_response(response_json):
    try:
        if 'candidates' in response_json and response_json['candidates']:
            parts = response_json['candidates'][0]['content']['parts']
            return "".join([p.get("text", "") for p in parts])
    except (KeyError, IndexError, TypeError) as e:
        log(f"⚠️ Failed to extract text: {e}")
    return None

def call_gemini_api(model, prompt, generation_config):
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}], "generationConfig": generation_config}

    try:
        response = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
    except requests.exceptions.RequestException as e:
        log(f"❌ Network Error ({model}): {e}")
        return None, 0 

    return response.json(), response.status_code

def ask_gemini_swarm(prompt, role="coder"):
    models = CODER_MODELS if role == "coder" else CRITIC_MODELS
    config = CODER_CONFIG if role == "coder" else CRITIC_CONFIG
    
    for model in models:
        if model in UNAVAILABLE_MODELS: continue 

        max_retries = 2
        for attempt in range(max_retries + 1):
            log(f"🔄 [{role.upper()}] {model} (Attempt {attempt+1})...")
            
            response_json, status_code = call_gemini_api(model, prompt, config)

            if status_code == 200:
                text = extract_text_from_response(response_json)
                if text:
                    time.sleep(1) # Tiny pause after success
                    return text
                else:
                    log(f"⚠️ Empty response from {model}")
                    break 
            
            elif status_code == 429:
                log(f"⏳ 429 Rate Limit on {model}")
                sleep_time = 5 * (2 ** attempt) # Aggressive backoff (5s, 10s, 20s)
                if attempt < max_retries:
                    log(f"   Sleeping {sleep_time:.2f}s...")
                    time.sleep(sleep_time)
                else:
                    log(f"   Skipping {model} due to persistent 429.")
            
            elif status_code == 404:
                log(f"🚫 Model Not Found: {model}. Marking unavailable.")
                UNAVAILABLE_MODELS.add(model)
                break 
            
            elif status_code >= 500:
                log(f"💥 Server Error {status_code}")
                time.sleep(5)
            else:
                log(f"❌ API Error {status_code}: {response_json}")
                break 

    log(f"❌ All models failed for role: {role}")
    return None

# --- PATCH ENGINE ---

def robust_fuzzy_replace(original, search_block, replace_block):
    if search_block in original:
        log("✅ Patch Method: Exact Match")
        return original.replace(search_block, replace_block), True

    if search_block.strip() in original:
        log("✅ Patch Method: Whitespace Strip Match")
        return original.replace(search_block.strip(), replace_block), True

    # Fuzzy Match
    matcher = difflib.SequenceMatcher(None, original, search_block)
    match = matcher.find_longest_match(0, len(original), 0, len(search_block))
    
    if match.size > 0:
        found_block = original[match.a : match.a + match.size]
        ratio = difflib.SequenceMatcher(None, found_block, search_block).ratio()
        
        if ratio >= 0.88:
            log(f"✅ Patch Method: Fuzzy Match (Score {ratio:.4f})")
            new_code = original[:match.a] + replace_block + original[match.a + match.size:]
            return new_code, True
        else:
            log(f"❌ Fuzzy match score too low ({ratio:.4f})")
    
    return original, False

def apply_patches(original_code, response_text):
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, response_text, re.DOTALL)
    
    if not matches: return None, "No valid SEARCH/REPLACE blocks found."

    current_code = original_code
    applied_count = 0
    
    for search_block, replace_block in matches:
        new_code, success = robust_fuzzy_replace(current_code, search_block, replace_block)
        if success:
            current_code = new_code
            applied_count += 1
        else:
            return None, f"Failed to match block:\n{search_block[:50]}..."

    if current_code == original_code: return None, "Code unchanged."
    if "<!DOCTYPE html>" not in current_code: return None, "CRITICAL: Root tags removed."

    return current_code, f"Applied {applied_count} patches."

# --- GIT & DEPLOY ---

def get_next_task():
    content = read_file("BACKLOG.md")
    if not content: return None
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', content)
    return match.group(1).strip() if match else None

def mark_task_done(task_name):
    content = read_file("BACKLOG.md")
    updated = content.replace(f"- [ ] **{task_name}**", f"- [x] **{task_name}**")
    write_file("BACKLOG.md", updated)

def mark_task_failed(task_name, reason):
    log(f"⚠️ Moving failed task to bottom: {task_name}")
    content = read_file("BACKLOG.md")
    task_line = f"- [ ] **{task_name}**"
    if task_line in content:
        content = content.replace(task_line, "").strip()
        footer = f"\n\n- [ ] **{task_name}** (Retry: {reason})"
        write_file("BACKLOG.md", content + footer)

def git_operations(task_name):
    if DRY_RUN: return True
    try:
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        if not repo.index.diff("HEAD"):
            log("⚠️ No git changes to commit.")
            return True
        repo.index.commit(f"feat(jules): {task_name}")
        log("🔄 Pulling & Pushing to GitHub...")
        repo.remotes.origin.pull(rebase=True)
        repo.remotes.origin.push()
        return True
    except Exception as e:
        log(f"❌ Git Error: {e}")
        return False

def check_render_deploy():
    if DRY_RUN or not RENDER_API_KEY: 
        log("⚠️ No Render Key: Skipping Check")
        return True
    
    log("🚀 Monitoring Render Deployment...")
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}

    for _ in range(20): 
        try:
            resp = requests.get(url, headers=headers, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                if data:
                    status = data[0]['deploy']['status']
                    log(f"📡 Render Status: {status}")
                    if status == "live": return True
                    if status in ["build_failed", "canceled"]: return False
        except: pass
        time.sleep(15)
    return True

# --- MAIN ---

def process_single_task():
    task = get_next_task()
    if not task:
        log("✅ No tasks found.")
        return False
    
    log(f"\n📋 TARGET: {task}")
    system_context = get_system_context()
    original_code = read_file("index.html")
    critique_history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt + 1}/{MAX_QA_RETRIES}...")

        prompt = f"""
{system_context}
---
TASK: {task}
CRITIQUE HISTORY: {critique_history}
INSTRUCTIONS: Return SEARCH/REPLACE blocks.
FORMAT:
<<<<<<< SEARCH
(code)
=======
(code)
>>>>>>> REPLACE
CODE CONTEXT:
{original_code}
"""
        response_text = ask_gemini_swarm(prompt, role="coder")
        if not response_text: continue

        new_code, patch_msg = apply_patches(original_code, response_text)
        if not new_code:
            log(f"❌ Patch Failed: {patch_msg}")
            critique_history = f"PATCH ERROR: {patch_msg}"
            continue
        
        log("🕵️ Critic Reviewing...")
        diff = "".join(difflib.unified_diff(original_code.splitlines(True), new_code.splitlines(True), n=3))
        critic_prompt = f"""
{truncate_content(system_context, 4000)}
---
ROLE: Critic. TASK: {task}. DIFF:
{diff}
Reply STRICTLY with "PASS" or "FAIL: reason".
"""
        critic_response = ask_gemini_swarm(critic_prompt, role="critic")
        
        if critic_response and "PASS" in critic_response.upper() and "FAIL" not in critic_response.upper():
            log("✅ QA Passed.")
            write_file("index.html", new_code)
            mark_task_done(task)
            if git_operations(task):
                check_render_deploy() # <--- HERE IS THE CHECK
            return True
        else:
            reason = critic_response if critic_response else "No response"
            log(f"❌ Critic FAILED: {reason}")
            critique_history = f"CRITIC REJECTED: {reason}"
            time.sleep(COOL_DOWN_SECONDS) # Prevent hammer

    mark_task_failed(task, "Max retries exhausted")
    log("⚠️ Task Failed: Skipping Render Check") # <--- Explicit log for you
    return True

def run():
    log("🤖 Jules Level 15 (STABILIZED) Started...")
    while True:
        if (time.time() - START_TIME) / 60 > MAX_RUNTIME_MINUTES: break
        if not process_single_task(): break
        time.sleep(5)

if __name__ == "__main__":
    run()


================================================================================
=== FILE: v31_20260116_0907_0d57f03.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- 1. CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")

# --- 2. MULTI-MODEL SWARM CONFIG ---
# Coder: Fast, Creative (Writes the fix)
CODER_MODELS = ["gemini-2.0-flash", "gemini-1.5-flash-latest", "gemini-2.0-flash-exp"]

# Sentinel: Smart, Strict (Checks for crashes)
SENTINEL_MODEL = "gemini-1.5-pro-latest"

# Critic: Standard Review (Checks logic)
CRITIC_MODELS = ["gemini-1.5-flash-latest", "gemini-2.0-flash"]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 60
UNAVAILABLE_MODELS = set() # Ghost Protocol

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- 3. INTELLIGENT API CALLER ---
def call_gemini(model_list, prompt, temp=0.1, role="coder"):
    # Ensure input is a list
    if isinstance(model_list, str): model_list = [model_list]
    
    for model in model_list:
        if model in UNAVAILABLE_MODELS: continue

        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"maxOutputTokens": 8192, "temperature": temp}
        }
        
        try:
            log(f"🔄 [{role.upper()}] Asking {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
            
            if resp.status_code == 200:
                try:
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                except: return None
            
            elif resp.status_code == 404:
                log(f"🚫 Ghost Protocol: {model} not found. Blacklisting.")
                UNAVAILABLE_MODELS.add(model)
            
            elif resp.status_code == 429:
                log(f"⏳ Rate Limit on {model}. Sleeping 5s...")
                time.sleep(5)
                
        except Exception as e:
            log(f"❌ API Error: {e}")
            
    return None

# --- 4. THE SENTINEL (SAFETY RAIL) ---
def sentinel_check(code, task):
    log("🛡️ Sentinel is scanning code for ReferenceErrors...")
    
    prompt = f"""
    ROLE: You are a Javascript Compiler.
    TASK: Scan this React code for CRITICAL CRASHES.
    
    LOOK FOR:
    1. Variables used in JSX (like 'toast', 'showModal') that are NOT defined in the component.
    2. Syntax Errors (unclosed brackets).
    
    CODE:
    {code[:15000]}... [truncated]
    
    OUTPUT:
    - If Safe: "PASS"
    - If Unsafe: "FAIL: [Reason]"
    """
    
    # We force the smartest model (1.5 Pro) for this check
    response = call_gemini([SENTINEL_MODEL], prompt, temp=0.0, role="sentinel")
    
    if response and "PASS" in response:
        return True, "Safe"
    return False, response or "No response"

# --- 5. SURGICAL PATCHING ---
def apply_patch(original, patch):
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    
    new_code = original
    for search, replace in matches:
        if search in new_code:
            new_code = new_code.replace(search, replace)
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
        else:
            # Fuzzy fallback could go here, but keeping it strict for safety first
            return None, "Search block match failed."
            
    if "<!DOCTYPE html>" not in new_code: return None, "CRITICAL: Root tag deleted."
    return new_code, "Applied"

# --- 6. RENDER WATCHDOG ---
def check_render():
    if not RENDER_API_KEY: 
        log("⚠️ No Render Key. Skipping Check.")
        return
    
    log("🚀 Watching Render Deployment...")
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    
    for _ in range(20): # 5 mins max
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": 
                    log("✅ Deployment Live.")
                    return
                if status in ["build_failed", "canceled"]:
                    log("❌ Deployment FAILED on Render.")
                    return
        except: pass
        time.sleep(15)

# --- MAIN LOOP ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', backlog)
    if not match: return False
    task = match.group(1)
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        # 1. CODER
        prompt = f"TASK: {task}\nCONTEXT: {read_file('AGENTS.md')}\nPREVIOUS_ERRORS: {history}\nCODE: {code}\nReturn SEARCH/REPLACE blocks."
        patch = call_gemini(CODER_MODELS, prompt, role="coder")
        if not patch: continue
        
        # 2. PATCH
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        # 3. SENTINEL
        is_safe, msg = sentinel_check(new_code, task)
        if not is_safe:
            log(f"🚫 SENTINEL BLOCKED: {msg}")
            history = f"Sentinel Compiler Error: {msg}"
            continue
            
        # 4. CRITIC
        critic_prompt = f"TASK: {task}\nReview this code change. Reply PASS or FAIL.\n\n{patch}"
        review = call_gemini(CRITIC_MODELS, critic_prompt, role="critic")
        if not review or "FAIL" in review:
            log(f"❌ Critic Rejected: {review}")
            history = review
            continue
            
        # 5. DEPLOY
        log("✅ ALL CHECKS PASSED. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = backlog.replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    # Fail Logic
    log("⚠️ Task stuck. Skipping.")
    new_backlog = backlog.replace(f"- [ ] **{task}**", f"- [ ] **{task}** (SKIPPED)")
    write_file("BACKLOG.md", new_backlog)
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    while process_task():
        time.sleep(5)


================================================================================
=== FILE: v32_20260116_0907_73d9aa2.py
=== DATE: 01/16/2026 10:11:05
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")

# --- MODEL SWARM CONFIGURATION ---
# Coder: Fast & Creative (Writes the code)
CODER_MODELS = ["gemini-2.0-flash", "gemini-1.5-flash-latest", "gemini-2.0-flash-exp"]

# Sentinel: Strict & Smart (The Compiler) - MUST be Pro level
SENTINEL_MODEL = "gemini-1.5-pro-latest"

# Critic: Standard Review (Logic checker)
CRITIC_MODELS = ["gemini-1.5-flash-latest", "gemini-2.0-flash"]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 60
UNAVAILABLE_MODELS = set() # Ghost Protocol Blacklist

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- INTELLIGENT API ENGINE ---
def call_gemini(model_list, prompt, temp=0.1, role="coder"):
    # Ensure input is a list so we can iterate
    if isinstance(model_list, str): model_list = [model_list]
    
    for model in model_list:
        if model in UNAVAILABLE_MODELS: continue

        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"maxOutputTokens": 8192, "temperature": temp}
        }
        
        try:
            log(f"🔄 [{role.upper()}] Asking {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
            
            if resp.status_code == 200:
                try:
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                except: return None
            
            elif resp.status_code == 404:
                log(f"🚫 Ghost Protocol: {model} not found. Blacklisting.")
                UNAVAILABLE_MODELS.add(model)
            
            elif resp.status_code == 429:
                log(f"⏳ Rate Limit on {model}. Sleeping 5s...")
                time.sleep(5)
                
        except Exception as e:
            log(f"❌ API Error: {e}")
            
    return None

# --- THE SENTINEL (SAFETY RAIL) ---
def sentinel_check(code, task):
    log("🛡️ Sentinel is scanning code for ReferenceErrors...")
    
    prompt = f"""
    ROLE: You are a STRICT Javascript Compiler.
    TASK: Scan this React code for CRITICAL RUNTIME ERRORS.
    
    CHECKLIST:
    1. Are all variables used in JSX (like 'toast', 'showModal') defined?
    2. Are Hooks (useState) inside the component?
    3. Are there Syntax Errors (unclosed brackets)?
    
    CODE:
    {code[:20000]}... [truncated]
    
    OUTPUT:
    - If Safe: "PASS"
    - If Unsafe: "FAIL: [Reason]"
    """
    
    # Force the smartest model (1.5 Pro) for this critical check
    response = call_gemini([SENTINEL_MODEL], prompt, temp=0.0, role="sentinel")
    
    if response and "PASS" in response:
        return True, "Safe"
    return False, response or "No response"

# --- SURGICAL PATCHING ---
def apply_patch(original, patch):
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    
    new_code = original
    for search, replace in matches:
        # 1. Exact Match
        if search in new_code:
            new_code = new_code.replace(search, replace)
        # 2. Whitespace-Insensitive Match
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
        else:
            return None, "Search block match failed."
            
    # SAFETY: Root Tag Protection
    if "<!DOCTYPE html>" not in new_code: return None, "CRITICAL: Root tag deleted."
    return new_code, "Applied"

# --- RENDER WATCHDOG ---
def check_render():
    if not RENDER_API_KEY: 
        log("⚠️ No Render Key. Skipping Check.")
        return
    
    log("🚀 Watching Render Deployment...")
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    
    for _ in range(20): # 5 mins max
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": 
                    log("✅ Deployment Live.")
                    return
                if status in ["build_failed", "canceled"]:
                    log("❌ Deployment FAILED on Render.")
                    return
        except: pass
        time.sleep(15)

# --- MAIN LOOP ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*', backlog)
    if not match: return False
    task = match.group(1)
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        # 1. CODER
        prompt = f"TASK: {task}\nCONTEXT: {read_file('AGENTS.md')}\nPREVIOUS_ERRORS: {history}\nCODE: {code}\nReturn SEARCH/REPLACE blocks."
        patch = call_gemini(CODER_MODELS, prompt, role="coder")
        if not patch: continue
        
        # 2. PATCH
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        # 3. SENTINEL (The Gatekeeper)
        is_safe, msg = sentinel_check(new_code, task)
        if not is_safe:
            log(f"🚫 SENTINEL BLOCKED: {msg}")
            history = f"Sentinel Compiler Error: {msg}"
            continue
            
        # 4. CRITIC
        critic_prompt = f"TASK: {task}\nReview this code change. Reply PASS or FAIL.\n\n{patch}"
        review = call_gemini(CRITIC_MODELS, critic_prompt, role="critic")
        if not review or "FAIL" in review:
            log(f"❌ Critic Rejected: {review}")
            history = review
            continue
            
        # 5. DEPLOY
        log("✅ ALL CHECKS PASSED. Committing...")
        write_file("index.html", new_code)
        
        # Update Backlog
        new_backlog = backlog.replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        # Git Push
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    # Failure Handling
    log("⚠️ Task stuck. Skipping.")
    new_backlog = backlog.replace(f"- [ ] **{task}**", f"- [ ] **{task}** (SKIPPED)")
    write_file("BACKLOG.md", new_backlog)
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    while process_task():
        time.sleep(5)


================================================================================
=== FILE: v33_20260116_1008_2c5cb83.py
=== DATE: 01/16/2026 10:11:06
================================================================================

import os
import re
import git
import requests
import json
import time
import sys
import random
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")

# --- MODELS ---
CODER_MODELS = ["gemini-2.0-flash", "gemini-1.5-flash-latest"]
SENTINEL_MODEL = "gemini-1.5-pro-latest"
MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 60
UNAVAILABLE_MODELS = set()

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

def call_gemini(model_list, prompt, temp=0.1, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    for model in model_list:
        if model in UNAVAILABLE_MODELS: continue
        url = f"[https://generativelanguage.googleapis.com/v1beta/models/](https://generativelanguage.googleapis.com/v1beta/models/){model}:generateContent?key={GEMINI_API_KEY}"
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"maxOutputTokens": 8192, "temperature": temp}
        }
        try:
            log(f"🔄 [{role.upper()}] Asking {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
            if resp.status_code == 200:
                try:
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                except: return None
            elif resp.status_code == 404:
                log(f"🚫 Ghost: {model} not found.")
                UNAVAILABLE_MODELS.add(model)
            elif resp.status_code == 429:
                log(f"⏳ Rate Limit on {model}. Sleeping 5s...")
                time.sleep(5)
        except Exception as e:
            log(f"❌ API Error: {e}")
    return None

def sentinel_check(code, task):
    log("🛡️ Sentinel scanning...")
    prompt = f"ROLE: JS Compiler.\nTASK: Check for ReferenceErrors.\nCODE: {code[:15000]}...\nOUTPUT: PASS or FAIL: reason"
    response = call_gemini([SENTINEL_MODEL], prompt, temp=0.0, role="sentinel")
    if response and "PASS" in response: return True, "Safe"
    return False, response or "No response"

def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    if "<<<<<<< SEARCH" not in clean_patch:
        log(f"⚠️ DEBUG - MODEL OUTPUT:\n{clean_patch[:300]}...")
        return None, "No SEARCH blocks found."

    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    
    if not matches: return None, "Regex failed."
    
    new_code = original
    for search, replace in matches:
        if search in new_code:
            new_code = new_code.replace(search, replace)
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
        else:
            return None, "Search block match failed."
            
    if "<!DOCTYPE html>" not in new_code: return None, "CRITICAL: Root tag deleted."
    return new_code, "Applied"

def check_render():
    if not RENDER_API_KEY: return
    log("🚀 Watching Render...")
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": return
                if status in ["build_failed", "canceled"]: return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name, reason="Stuck"):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    
    # 1. Filter out the stuck task
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED: {reason})"
        else:
            new_lines.append(line)
    
    # 2. Append to bottom
    if task_line:
        new_lines.append("") 
        new_lines.append("## ⚠️ SKIPPED TASKS")
        new_lines.append(task_line)
        
    write_file("BACKLOG.md", "\n".join(new_lines))

def process_task():
    backlog = read_file("BACKLOG.md")
    # Fix regex to ignore (SKIPPED) tasks
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        prompt = f"""
TASK: {task}
CONTEXT: {read_file('AGENTS.md')}
PREVIOUS_ERRORS: {history}
CODE: {code}

INSTRUCTIONS:
1. Return ONLY the SEARCH/REPLACE blocks.
2. DO NOT wrap in Markdown (no `).

FORMAT:
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE
"""
        patch = call_gemini(CODER_MODELS, prompt, role="coder")
        if not patch: continue
        
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        is_safe, msg = sentinel_check(new_code, task)
        if not is_safe:
            log(f"🚫 SENTINEL BLOCKED: {msg}")
            history = msg
            continue
            
        log("✅ SUCCESS. Committing...")
        write_file("index.html", new_code)
        
        # Mark Done
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    log("⚠️ Task stuck. Moving to bottom.")
    move_task_to_bottom(task)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    while process_task():
        time.sleep(5)


================================================================================
=== FILE: v34_20260116_1040_LEVEL_20_MASTER.py
=== DATE: 01/16/2026 10:40:16
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- 1. CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")

# --- 2. MULTI-MODEL SWARM ---
# Coder: Fast, Creative (Writes the fix)
CODER_MODELS = ["gemini-2.0-flash", "gemini-1.5-flash-latest", "gemini-2.0-flash-exp"]

# Sentinel: Smart, Strict (The Compiler) - Must be high reasoning
SENTINEL_MODEL = "gemini-1.5-pro-latest"

# Critic: Standard Review (Logic checker) - Restored from v29
CRITIC_MODELS = ["gemini-1.5-flash-latest", "gemini-2.0-flash"]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 60
UNAVAILABLE_MODELS = set() # Ghost Protocol

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- 3. CONTEXT ENGINE (Restored from v29) ---
def truncate_content(content, max_chars=12000):
    if len(content) <= max_chars: return content
    half = max_chars // 2
    return content[:half] + "\n\n... [TRUNCATED] ...\n\n" + content[-half:]

def get_system_context():
    context_buffer = ""
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    for doc in doc_files:
        content = read_file(doc)
        if content:
            content = truncate_content(content)
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
    return context_buffer

# --- 4. INTELLIGENT API CALLER ---
def call_gemini(model_list, prompt, temp=0.1, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    for model in model_list:
        if model in UNAVAILABLE_MODELS: continue

        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"maxOutputTokens": 8192, "temperature": temp}
        }
        
        try:
            log(f"🔄 [{role.upper()}] Asking {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
            
            if resp.status_code == 200:
                try:
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                except: return None
            
            elif resp.status_code == 404:
                log(f"🚫 Ghost Protocol: {model} not found.")
                UNAVAILABLE_MODELS.add(model)
            
            elif resp.status_code == 429:
                log(f"⏳ Rate Limit on {model}. Sleeping 5s...")
                time.sleep(5)
                
        except Exception as e:
            log(f"❌ API Error: {e}")
            
    return None

# --- 5. THE SENTINEL (SAFETY RAIL) ---
def sentinel_check(code, task):
    log("🛡️ Sentinel is scanning code for ReferenceErrors...")
    
    prompt = f"""
    ROLE: You are a STRICT Javascript Compiler.
    TASK: Scan this React code for CRITICAL RUNTIME ERRORS.
    
    CHECKLIST:
    1. Are all variables used in JSX (like 'toast', 'showModal') defined?
    2. Are Hooks (useState) inside the component?
    3. Are there Syntax Errors (unclosed brackets)?
    
    CODE:
    {code[:20000]}... [truncated]
    
    OUTPUT:
    - If Safe: "PASS"
    - If Unsafe: "FAIL: [Reason]"
    """
    
    response = call_gemini([SENTINEL_MODEL], prompt, temp=0.0, role="sentinel")
    if response and "PASS" in response:
        return True, "Safe"
    return False, response or "No response"

# --- 6. SURGICAL PATCHING (Hybrid: Regex + Fuzzy) ---
def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    
    new_code = original
    applied_count = 0
    
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            applied_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            applied_count += 1
        else:
            log("⚠️ Exact match failed. Attempting Fuzzy Match...")
            matcher = difflib.SequenceMatcher(None, new_code, search_block)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search_block))
            if match.size > 0:
                found_block = new_code[match.a : match.a + match.size]
                ratio = difflib.SequenceMatcher(None, found_block, search_block).ratio()
                if ratio >= 0.85:
                    log(f"✅ Fuzzy Match Applied (Score: {ratio:.2f})")
                    new_code = new_code[:match.a] + replace_block + new_code[match.a + match.size:]
                    applied_count += 1
                else:
                    return None, f"Block match failed (Fuzzy score {ratio:.2f} too low)."

    if "<!DOCTYPE html>" not in new_code: return None, "CRITICAL: Root tag deleted."
    return new_code, f"Applied {applied_count} patches"

# --- 7. DEPLOYMENT & TASK MANAGEMENT ---
def check_render():
    if not RENDER_API_KEY: 
        log("⚠️ No Render Key. Skipping Check.")
        return
    
    log("🚀 Watching Render Deployment...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": 
                    log("✅ Deployment Live.")
                    return
                if status in ["build_failed", "canceled"]:
                    log("❌ Deployment FAILED on Render.")
                    return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name, reason="Stuck"):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED: {reason})"
        else:
            new_lines.append(line)
            
    if task_line:
        new_lines.append("") 
        new_lines.append("## ⚠️ SKIPPED TASKS")
        new_lines.append(task_line)
        
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN LOOP ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    system_context = get_system_context()
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        # 1. CODER
        prompt = f"""
TASK: {task}
{system_context}
PREVIOUS_ERRORS: {history}
CODE: {code}

INSTRUCTIONS:
1. Return ONLY the SEARCH/REPLACE blocks.
2. DO NOT wrap in Markdown (no `).

FORMAT:
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE
"""
        patch = call_gemini(CODER_MODELS, prompt, role="coder")
        if not patch: continue
        
        # 2. PATCH
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        # 3. SENTINEL
        is_safe, msg = sentinel_check(new_code, task)
        if not is_safe:
            log(f"🚫 SENTINEL BLOCKED: {msg}")
            history = f"Sentinel Compiler Error: {msg}"
            continue
            
        # 4. CRITIC
        log("🕵️ Critic Reviewing...")
        critic_prompt = f"TASK: {task}\nReview this code change. Reply PASS or FAIL.\n\nPATCH:\n{patch}"
        review = call_gemini(CRITIC_MODELS, critic_prompt, role="critic")
        if not review or "FAIL" in review:
            log(f"❌ Critic Rejected: {review}")
            history = review
            continue

        # 5. DEPLOY
        log("✅ ALL CHECKS PASSED. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    log("⚠️ Task stuck. Moving to bottom.")
    move_task_to_bottom(task)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    while process_task():
        time.sleep(5)
================================================================================
=== FILE: v35_20260116_1047_LEVEL_22_NO_1.5.py
=== DATE: 01/16/2026 10:47:47
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- 1. CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
RENDER_API_KEY = os.environ.get("RENDER_API_KEY")
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID")

# --- 2. MODEL STACK (NO 1.5 ALLOWED) ---
# Coder: Tries the bleeding edge first, falls back to 2.0 Flash
CODER_MODELS = ["gemini-3.0-pro-preview", "gemini-2.0-flash-exp", "gemini-2.0-flash"]

# Sentinel: Uses 2.0 Flash Exp (High reasoning, no 1.5)
SENTINEL_MODELS = ["gemini-2.0-flash-exp", "gemini-2.0-flash"]

# Critic: Uses 2.0 Flash (Fast & Strict)
CRITIC_MODELS = ["gemini-2.0-flash"]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 60
UNAVAILABLE_MODELS = set() # Ghost Protocol

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- 3. CONTEXT ENGINE ---
def truncate_content(content, max_chars=12000):
    if len(content) <= max_chars: return content
    half = max_chars // 2
    return content[:half] + "\n\n... [TRUNCATED] ...\n\n" + content[-half:]

def get_system_context():
    context_buffer = ""
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    for doc in doc_files:
        content = read_file(doc)
        if content:
            content = truncate_content(content)
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
    return context_buffer

# --- 4. INTELLIGENT API CALLER ---
def call_gemini(model_list, prompt, temp=0.1, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    for model in model_list:
        if model in UNAVAILABLE_MODELS: continue

        url = f"[https://generativelanguage.googleapis.com/v1beta/models/](https://generativelanguage.googleapis.com/v1beta/models/){model}:generateContent?key={GEMINI_API_KEY}"
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"maxOutputTokens": 8192, "temperature": temp}
        }
        
        try:
            log(f"🔄 [{role.upper()}] Asking {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
            
            if resp.status_code == 200:
                try:
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                except: return None
            
            elif resp.status_code == 404:
                log(f"🚫 Ghost Protocol: {model} not found.")
                UNAVAILABLE_MODELS.add(model)
            
            elif resp.status_code == 429:
                log(f"⏳ Rate Limit on {model}. Sleeping 10s...")
                time.sleep(10)
                
        except Exception as e:
            log(f"❌ API Error: {e}")
            
    return None

# --- 5. THE SENTINEL (SAFETY RAIL) ---
def sentinel_check(code, task):
    log("🛡️ Sentinel is scanning code for ReferenceErrors...")
    
    prompt = f"""
    ROLE: You are a STRICT Javascript Compiler.
    TASK: Scan this React code for CRITICAL RUNTIME ERRORS.
    
    CHECKLIST:
    1. Are all variables used in JSX (like 'toast', 'showModal') defined?
    2. Are Hooks (useState) inside the component?
    3. Are there Syntax Errors (unclosed brackets)?
    
    CODE:
    {code[:20000]}... [truncated]
    
    OUTPUT:
    - If Safe: "PASS"
    - If Unsafe: "FAIL: [Reason]"
    """
    
    # Using 2.0 models now
    response = call_gemini(SENTINEL_MODELS, prompt, temp=0.0, role="sentinel")
    if response and "PASS" in response:
        return True, "Safe"
    return False, response or "No response (Sentinel failed)"

# --- 6. SURGICAL PATCHING (Hybrid) ---
def apply_patch(original, patch):
    # Markdown Stripper
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    
    new_code = original
    applied_count = 0
    
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            applied_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            applied_count += 1
        else:
            log("⚠️ Exact match failed. Attempting Fuzzy Match...")
            matcher = difflib.SequenceMatcher(None, new_code, search_block)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search_block))
            if match.size > 0:
                found_block = new_code[match.a : match.a + match.size]
                ratio = difflib.SequenceMatcher(None, found_block, search_block).ratio()
                if ratio >= 0.85:
                    log(f"✅ Fuzzy Match Applied (Score: {ratio:.2f})")
                    new_code = new_code[:match.a] + replace_block + new_code[match.a + match.size:]
                    applied_count += 1
                else:
                    return None, f"Block match failed (Fuzzy score {ratio:.2f} too low)."

    if "<!DOCTYPE html>" not in new_code: return None, "CRITICAL: Root tag deleted."
    return new_code, f"Applied {applied_count} patches"

# --- 7. DEPLOYMENT & TASK MANAGEMENT ---
def check_render():
    if not RENDER_API_KEY: 
        log("⚠️ No Render Key. Skipping Check.")
        return
    
    log("🚀 Watching Render Deployment...")
    url = f"https://api.render.com/v1/services/{RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": 
                    log("✅ Deployment Live.")
                    return
                if status in ["build_failed", "canceled"]:
                    log("❌ Deployment FAILED on Render.")
                    return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name, reason="Stuck"):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED: {reason})"
        else:
            new_lines.append(line)
            
    if task_line:
        new_lines.append("") 
        new_lines.append("## ⚠️ SKIPPED TASKS")
        new_lines.append(task_line)
        
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN LOOP ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    system_context = get_system_context()
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        # 1. CODER
        prompt = f"""
TASK: {task}
{system_context}
PREVIOUS_ERRORS: {history}
CODE: {code}

INSTRUCTIONS:
1. Return ONLY the SEARCH/REPLACE blocks.
2. DO NOT wrap in Markdown (no `).

FORMAT:
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE
"""
        patch = call_gemini(CODER_MODELS, prompt, role="coder")
        if not patch: continue
        
        # 2. PATCH
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        # 3. SENTINEL
        is_safe, msg = sentinel_check(new_code, task)
        if not is_safe:
            log(f"🚫 SENTINEL BLOCKED: {msg}")
            history = f"Sentinel Compiler Error: {msg}"
            continue
            
        # 4. CRITIC
        log("🕵️ Critic Reviewing...")
        critic_prompt = f"TASK: {task}\nReview this code change. Reply PASS or FAIL.\n\nPATCH:\n{patch}"
        review = call_gemini(CRITIC_MODELS, critic_prompt, role="critic")
        if not review or "FAIL" in review:
            log(f"❌ Critic Rejected: {review}")
            history = review
            continue

        # 5. DEPLOY
        log("✅ ALL CHECKS PASSED. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    log("⚠️ Task stuck. Moving to bottom.")
    move_task_to_bottom(task)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    while process_task():
        time.sleep(5)

================================================================================
=== FILE: v36_20260116_1054_LEVEL_23_SANITIZED.py
=== DATE: 01/16/2026 10:54:02
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- 1. CONFIGURATION ---
REPO_PATH = "."
# SANITIZATION: Strip whitespace/newlines immediately upon loading
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "").strip()
RENDER_API_KEY = os.environ.get("RENDER_API_KEY", "").strip()
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID", "").strip()

# --- 2. MODEL STACK (NO 1.5 ALLOWED) ---
CODER_MODELS = ["gemini-3.0-pro-preview", "gemini-2.0-flash-exp", "gemini-2.0-flash"]
SENTINEL_MODELS = ["gemini-2.0-flash-exp", "gemini-2.0-flash"]
CRITIC_MODELS = ["gemini-2.0-flash"]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 60
UNAVAILABLE_MODELS = set()

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- 3. CONTEXT ENGINE ---
def truncate_content(content, max_chars=12000):
    if len(content) <= max_chars: return content
    half = max_chars // 2
    return content[:half] + "\n\n... [TRUNCATED] ...\n\n" + content[-half:]

def get_system_context():
    context_buffer = ""
    doc_files = ["AGENTS.md", "ARCHITECTURE.md", "TESTING_PROTOCOL.md"]
    for doc in doc_files:
        content = read_file(doc)
        if content:
            content = truncate_content(content)
            context_buffer += f"\n\n=== SYSTEM CONTEXT: {doc} ===\n{content}\n"
    return context_buffer

# --- 4. INTELLIGENT API CALLER ---
def call_gemini(model_list, prompt, temp=0.1, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    for model in model_list:
        model = model.strip() # Extra safety
        if model in UNAVAILABLE_MODELS: continue

        # URL Construction: Ensure no spaces/newlines
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"maxOutputTokens": 8192, "temperature": temp}
        }
        
        try:
            log(f"🔄 [{role.upper()}] Asking {model}...")
            resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
            
            if resp.status_code == 200:
                try:
                    return resp.json()['candidates'][0]['content']['parts'][0]['text']
                except: return None
            
            elif resp.status_code == 404:
                log(f"🚫 Ghost Protocol: {model} not found (404).")
                UNAVAILABLE_MODELS.add(model)
            
            elif resp.status_code == 429:
                log(f"⏳ Rate Limit on {model}. Sleeping 10s...")
                time.sleep(10)
            else:
                log(f"❌ API Error {resp.status_code}: {resp.text}")
                
        except Exception as e:
            log(f"❌ Connection Failed: {type(e).__name__}: {e}")
            
    return None

# --- 5. THE SENTINEL (SAFETY RAIL) ---
def sentinel_check(code, task):
    log("🛡️ Sentinel is scanning code for ReferenceErrors...")
    
    prompt = f"""
    ROLE: You are a STRICT Javascript Compiler.
    TASK: Scan this React code for CRITICAL RUNTIME ERRORS.
    
    CHECKLIST:
    1. Are all variables used in JSX (like 'toast', 'showModal') defined?
    2. Are Hooks (useState) inside the component?
    3. Are there Syntax Errors (unclosed brackets)?
    
    CODE:
    {code[:20000]}... [truncated]
    
    OUTPUT:
    - If Safe: "PASS"
    - If Unsafe: "FAIL: [Reason]"
    """
    
    response = call_gemini(SENTINEL_MODELS, prompt, temp=0.0, role="sentinel")
    if response and "PASS" in response:
        return True, "Safe"
    return False, response or "No response (Sentinel failed)"

# --- 6. SURGICAL PATCHING ---
def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    
    new_code = original
    applied_count = 0
    
    for search_block, replace_block in matches:
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            applied_count += 1
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            applied_count += 1
        else:
            log("⚠️ Exact match failed. Attempting Fuzzy Match...")
            matcher = difflib.SequenceMatcher(None, new_code, search_block)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search_block))
            if match.size > 0:
                found_block = new_code[match.a : match.a + match.size]
                ratio = difflib.SequenceMatcher(None, found_block, search_block).ratio()
                if ratio >= 0.85:
                    log(f"✅ Fuzzy Match Applied (Score: {ratio:.2f})")
                    new_code = new_code[:match.a] + replace_block + new_code[match.a + match.size:]
                    applied_count += 1
                else:
                    return None, f"Block match failed (Fuzzy score {ratio:.2f} too low)."

    if "<!DOCTYPE html>" not in new_code: return None, "CRITICAL: Root tag deleted."
    return new_code, f"Applied {applied_count} patches"

# --- 7. DEPLOYMENT & TASK MANAGEMENT ---
def check_render():
    if not RENDER_API_KEY: 
        log("⚠️ No Render Key. Skipping Check.")
        return
    
    log("🚀 Watching Render Deployment...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": 
                    log("✅ Deployment Live.")
                    return
                if status in ["build_failed", "canceled"]:
                    log("❌ Deployment FAILED on Render.")
                    return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name, reason="Stuck"):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED: {reason})"
        else:
            new_lines.append(line)
            
    if task_line:
        new_lines.append("") 
        new_lines.append("## ⚠️ SKIPPED TASKS")
        new_lines.append(task_line)
        
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN LOOP ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    system_context = get_system_context()
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        # 1. CODER
        prompt = f"""
TASK: {task}
{system_context}
PREVIOUS_ERRORS: {history}
CODE: {code}

INSTRUCTIONS:
1. Return ONLY the SEARCH/REPLACE blocks.
2. DO NOT wrap in Markdown (no `).

FORMAT:
<<<<<<< SEARCH
(exact code to remove)
=======
(new code to insert)
>>>>>>> REPLACE
"""
        patch = call_gemini(CODER_MODELS, prompt, role="coder")
        if not patch: continue
        
        # 2. PATCH
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        # 3. SENTINEL
        is_safe, msg = sentinel_check(new_code, task)
        if not is_safe:
            log(f"🚫 SENTINEL BLOCKED: {msg}")
            history = f"Sentinel Compiler Error: {msg}"
            continue
            
        # 4. CRITIC
        log("🕵️ Critic Reviewing...")
        critic_prompt = f"TASK: {task}\nReview this code change. Reply PASS or FAIL.\n\nPATCH:\n{patch}"
        review = call_gemini(CRITIC_MODELS, critic_prompt, role="critic")
        if not review or "FAIL" in review:
            log(f"❌ Critic Rejected: {review}")
            history = review
            continue

        # 5. DEPLOY
        log("✅ ALL CHECKS PASSED. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    log("⚠️ Task stuck. Moving to bottom.")
    move_task_to_bottom(task)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    while process_task():
        time.sleep(5)

================================================================================
=== FILE: v37_20260116_1103_LEVEL_24_HYBRID_RESTORE.py
=== DATE: 01/16/2026 11:03:53
=== NOTE: Restored Level 9 Brain + Level 23 Safety Fixes (Sanitization, Markdown Strip)
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import random
import difflib
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."
# SANITIZATION: Critical fix for connection errors
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "").strip()
RENDER_API_KEY = os.environ.get("RENDER_API_KEY", "").strip()
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID", "").strip()

# --- MODEL CONFIG (Restored Level 9 Stack) ---
# We use the smartest models because Level 9 proved they can write the complex React code.
CODER_MODELS = ["gemini-3-pro-preview", "gemini-2.0-flash-exp"]
CRITIC_MODEL = "gemini-3-pro-preview" 

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 90 # Increased for 3.0 Pro
START_TIME = time.time()
MAX_RUNTIME_MINUTES = 60

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- API ENGINE (Simplified from Level 9) ---
def ask_gemini(prompt, model_list, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}
    }
    
    for model in model_list:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        for attempt in range(2):
            try:
                log(f"🔄 [{role.upper()}] Asking {model} (Attempt {attempt+1})...")
                resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
                
                if resp.status_code == 200:
                    try:
                        return resp.json()['candidates'][0]['content']['parts'][0]['text']
                    except: return None
                elif resp.status_code == 429:
                    log(f"⏳ Rate Limit. Sleeping 10s...")
                    time.sleep(10)
                elif resp.status_code == 404:
                    log(f"🚫 {model} not found. Skipping.")
                    break # Next model
                else:
                    log(f"❌ Error {resp.status_code}: {resp.text[:200]}")
                    
            except Exception as e:
                log(f"❌ Network Error: {e}")
    return None

# --- PATCH ENGINE (Level 9 + Markdown Stripper) ---
def apply_patch(original, patch):
    # FIX: Strip markdown code fences which caused Level 9 to fail on 'Set Deletion'
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    
    if not matches:
        return None, "No blocks found. (Parser failed to find SEARCH/REPLACE pattern)"
    
    new_code = original
    applied_count = 0
    
    for search_block, replace_block in matches:
        # 1. Exact Match
        if search_block in new_code:
            new_code = new_code.replace(search_block, replace_block)
            applied_count += 1
        # 2. Whitespace Strip Match (The "Fuzzy" Logic from Level 9)
        elif search_block.strip() in new_code:
            new_code = new_code.replace(search_block.strip(), replace_block.strip())
            applied_count += 1
        else:
            return None, f"Block match failed. Could not find:\n{search_block[:50]}..."

    return new_code, f"Applied {applied_count} patches"

# --- VERIFICATION (The Level 9 Critic) ---
def verify_fix(task, original, new_code):
    if original == new_code: return False, "No changes detected."
    
    # Send a diff to the critic so it focuses on the changes
    diff = "".join(difflib.unified_diff(original.splitlines(True), new_code.splitlines(True), n=3))
    
    prompt = f"""
    ROLE: Senior Code Reviewer.
    TASK: {task}
    DIFF:
    {diff}
    
    VERIFICATION CHECKLIST:
    1. Does this fix the task?
    2. Are there syntax errors?
    3. Did it accidentally delete unrelated code?
    
    OUTPUT: 'PASS' or 'FAIL: [reason]'
    """
    
    response = ask_gemini(prompt, CRITIC_MODEL, role="critic")
    if not response: return True, "Critic silent, assuming safe."
    
    if "PASS" in response.upper(): return True, "Verified."
    return False, response

# --- DEPLOYMENT ---
def check_render():
    if not RENDER_API_KEY: return
    log("🚀 Watching Render...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200:
                status = resp.json()[0]['deploy']['status']
                log(f"📡 Status: {status}")
                if status == "live": return
                if status in ["build_failed", "canceled"]: return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED)"
        else:
            new_lines.append(line)
    if task_line:
        new_lines.append("")
        new_lines.append("## ⚠️ SKIPPED TASKS")
        new_lines.append(task_line)
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    history = ""
    
    # Load minimal context (AGENTS.md only to keep tokens low, like Level 9)
    context = read_file("AGENTS.md")
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        prompt = f"""
TASK: {task}
CONTEXT: {context}
PREVIOUS ERRORS: {history}

INSTRUCTIONS:
1. Output SEARCH/REPLACE blocks.
2. NO MARKDOWN formatting (Do not use `).
3. Be precise with whitespace in SEARCH blocks.

CODE:
{code}
"""
        # 1. GENERATE
        patch = ask_gemini(prompt, CODER_MODELS, role="coder")
        if not patch: continue
        
        # 2. PATCH
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = f"Your SEARCH block failed to match. {status}"
            continue
            
        # 3. CRITIC
        is_valid, msg = verify_fix(task, code, new_code)
        if not is_valid:
            log(f"❌ Critic Rejected: {msg}")
            history = f"Critic feedback: {msg}"
            continue
            
        # 4. DEPLOY
        log("✅ QA Passed. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        
        check_render()
        return True

    log("⚠️ Task stuck. Moving to bottom.")
    move_task_to_bottom(task)
    
    repo = git.Repo(REPO_PATH)
    repo.git.add("BACKLOG.md")
    repo.index.commit("skip: stuck task")
    repo.remotes.origin.push()
    return True

if __name__ == "__main__":
    log("🤖 Jules Level 24 (HYBRID RESTORE) Started...")
    while process_task():
        time.sleep(5)

================================================================================
=== FILE: v38_20260116_1342_LEVEL_26_CONNECTION_FIX.py
=== DATE: 01/16/2026 13:42:38
=== NOTE: Added Nuclear Sanitization for API Keys + Pre-flight Connection Check
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import difflib
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."

# NUCLEAR SANITIZATION: This fixes the "No Connection Adapters" error
# We explicitly remove newlines (\n, \r) and whitespace.
raw_key = os.environ.get("GEMINI_API_KEY", "")
GEMINI_API_KEY = raw_key.replace("\n", "").replace("\r", "").strip()

RENDER_API_KEY = os.environ.get("RENDER_API_KEY", "").replace("\n", "").replace("\r", "").strip()
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID", "").replace("\n", "").replace("\r", "").strip()

# --- MODEL STACK (The "Level 9" Configuration) ---
CODER_MODELS = ["gemini-3.0-pro-preview", "gemini-2.0-flash-exp"]
CRITIC_MODEL = "gemini-2.0-flash-exp"

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 90

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- PRE-FLIGHT CHECK ---
def test_connection():
    """Verifies that the API Key is clean and working before we start."""
    log("🔌 Testing API Connection...")
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": "Hello"}]}]}
    
    try:
        resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=10)
        if resp.status_code == 200:
            log("✅ API Connection Successful.")
            return True
        else:
            log(f"❌ API Test Failed: {resp.status_code} - {resp.text}")
            return False
    except Exception as e:
        log(f"❌ Connection Error: {e}")
        log("💡 HINT: Your API Key might still have a hidden newline. Check your environment variables.")
        return False

# --- API ENGINE ---
def ask_gemini(prompt, model_list, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}
    }
    
    for model in model_list:
        model = model.replace("\n", "").strip() # Double safety
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        for attempt in range(2):
            try:
                log(f"🔄 [{role.upper()}] Asking {model}...")
                resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
                
                if resp.status_code == 200:
                    try:
                        return resp.json()['candidates'][0]['content']['parts'][0]['text']
                    except: return None
                elif resp.status_code == 429:
                    log(f"⏳ Rate Limit. Sleeping 10s...")
                    time.sleep(10)
                elif resp.status_code == 404:
                    log(f"🚫 {model} not found.")
                    break
                else:
                    log(f"❌ Error {resp.status_code}: {resp.text[:200]}")
                    
            except Exception as e:
                log(f"❌ Network Error: {e}")
    return None

# --- PATCH ENGINE (Markdown Stripper) ---
def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    
    if not matches: return None, "No blocks found."
    
    new_code = original
    applied_count = 0
    
    for search, replace in matches:
        if search in new_code:
            new_code = new_code.replace(search, replace)
            applied_count += 1
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
            applied_count += 1
        else:
             # Basic fuzzy fallback
            matcher = difflib.SequenceMatcher(None, new_code, search)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search))
            if match.size > 0 and (match.size / len(search) > 0.8):
                 new_code = new_code[:match.a] + replace + new_code[match.a + match.size:]
                 applied_count += 1

    return new_code, f"Applied {applied_count} patches"

# --- DEPLOYMENT ---
def check_render():
    if not RENDER_API_KEY: return
    log("🚀 Watching Render...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200 and resp.json()[0]['deploy']['status'] == "live":
                log("✅ Deployment Live.")
                return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED)"
        else:
            new_lines.append(line)
    if task_line:
        new_lines.append(""); new_lines.append("## ⚠️ SKIPPED TASKS"); new_lines.append(task_line)
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    context = read_file("AGENTS.md")
    history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        prompt = f"TASK: {task}\nCONTEXT: {context}\nERRORS: {history}\nCODE:\n{code}\n\nINSTRUCTIONS: Return SEARCH/REPLACE blocks. NO markdown."
        patch = ask_gemini(prompt, CODER_MODELS, role="coder")
        if not patch: continue
        
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        log("✅ Logic Verified. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        check_render()
        return True

    move_task_to_bottom(task)
    return True

if __name__ == "__main__":
    if test_connection():
        log("🤖 Jules Level 26 (CONNECTION FIXED) Started...")
        while process_task():
            time.sleep(5)
    else:
        log("🛑 Aborting due to connection failure.")

================================================================================
=== FILE: v39_20260116_1346_LEVEL_27_FRESH_MODELS.py
=== DATE: 01/16/2026 13:46:18
=== NOTE: Switched to gemini-2.0-flash to avoid 404/429 errors from exhausted models.
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import difflib
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."

# NUCLEAR SANITIZATION
raw_key = os.environ.get("GEMINI_API_KEY", "")
GEMINI_API_KEY = raw_key.replace("\n", "").replace("\r", "").strip()
RENDER_API_KEY = os.environ.get("RENDER_API_KEY", "").replace("\n", "").replace("\r", "").strip()
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID", "").replace("\n", "").replace("\r", "").strip()

# --- MODEL STACK (THE "GREEN BAR" MODELS) ---
# We prioritized these based on your usage dashboard availability.
CODER_MODELS = [
    "gemini-2.0-flash",      # PRIMARY: Fast, Smart, High Quota
    "gemini-1.5-flash",      # BACKUP: Extremely reliable
    "gemini-2.5-flash"       # TERTIARY: If available
]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 90

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- PRE-FLIGHT ---
def test_connection():
    log(f"🔌 Testing Connection with {CODER_MODELS[0]}...")
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{CODER_MODELS[0]}:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": "Hello"}]}]}
    try:
        resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=10)
        if resp.status_code == 200:
            log("✅ Connection Valid.")
            return True
        else:
            log(f"❌ Connection Failed: {resp.status_code} - {resp.text}")
            return False
    except Exception as e:
        log(f"❌ Network Error: {e}")
        return False

# --- API ENGINE ---
def ask_gemini(prompt, model_list, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}
    }
    
    for model in model_list:
        model = model.strip()
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        for attempt in range(2):
            try:
                log(f"🔄 [{role.upper()}] Asking {model}...")
                resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
                
                if resp.status_code == 200:
                    try:
                        return resp.json()['candidates'][0]['content']['parts'][0]['text']
                    except: return None
                elif resp.status_code == 429:
                    log(f"⏳ {model} Rate Limit. Switching to backup...")
                    time.sleep(2)
                    break 
                elif resp.status_code == 404:
                    log(f"🚫 {model} not found. Switching...")
                    break
                else:
                    log(f"❌ Error {resp.status_code}: {resp.text[:100]}...")
                    
            except Exception as e:
                log(f"❌ Network Error: {e}")
    return None

# --- PATCH ENGINE ---
def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    new_code = original
    applied_count = 0
    for search, replace in matches:
        if search in new_code:
            new_code = new_code.replace(search, replace)
            applied_count += 1
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
            applied_count += 1
        else:
            matcher = difflib.SequenceMatcher(None, new_code, search)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search))
            if match.size > 0 and (match.size / len(search) > 0.8):
                 new_code = new_code[:match.a] + replace + new_code[match.a + match.size:]
                 applied_count += 1
    return new_code, f"Applied {applied_count} patches"

# --- DEPLOYMENT ---
def check_render():
    if not RENDER_API_KEY: return
    log("🚀 Watching Render...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200 and resp.json()[0]['deploy']['status'] == "live":
                log("✅ Deployment Live.")
                return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED)"
        else:
            new_lines.append(line)
    if task_line:
        new_lines.append(""); new_lines.append("## ⚠️ SKIPPED TASKS"); new_lines.append(task_line)
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    context = read_file("AGENTS.md")
    history = ""
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        prompt = f"TASK: {task}\nCONTEXT: {context}\nERRORS: {history}\nCODE:\n{code}\n\nINSTRUCTIONS: Return SEARCH/REPLACE blocks. NO markdown."
        patch = ask_gemini(prompt, CODER_MODELS, role="coder")
        if not patch: continue
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
        log("✅ Verified. Committing...")
        write_file("index.html", new_code)
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        check_render()
        return True
    move_task_to_bottom(task)
    return True

if __name__ == "__main__":
    if test_connection():
        log("🤖 Jules Level 27 (FRESH MODELS) Started...")
        while process_task():
            time.sleep(5)
    else:
        log("🛑 Aborting.")

================================================================================
=== FILE: v39_20260116_1346_LEVEL_27_FRESH_MODELS.py
=== DATE: 01/16/2026 13:46:21
=== NOTE: Switched to gemini-2.0-flash to avoid 404/429 errors from exhausted models.
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import difflib
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."

# NUCLEAR SANITIZATION
raw_key = os.environ.get("GEMINI_API_KEY", "")
GEMINI_API_KEY = raw_key.replace("\n", "").replace("\r", "").strip()
RENDER_API_KEY = os.environ.get("RENDER_API_KEY", "").replace("\n", "").replace("\r", "").strip()
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID", "").replace("\n", "").replace("\r", "").strip()

# --- MODEL STACK (THE "GREEN BAR" MODELS) ---
# We prioritized these based on your usage dashboard availability.
CODER_MODELS = [
    "gemini-2.0-flash",      # PRIMARY: Fast, Smart, High Quota
    "gemini-1.5-flash",      # BACKUP: Extremely reliable
    "gemini-2.5-flash"       # TERTIARY: If available
]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 90

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- PRE-FLIGHT ---
def test_connection():
    log(f"🔌 Testing Connection with {CODER_MODELS[0]}...")
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{CODER_MODELS[0]}:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": "Hello"}]}]}
    try:
        resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=10)
        if resp.status_code == 200:
            log("✅ Connection Valid.")
            return True
        else:
            log(f"❌ Connection Failed: {resp.status_code} - {resp.text}")
            return False
    except Exception as e:
        log(f"❌ Network Error: {e}")
        return False

# --- API ENGINE ---
def ask_gemini(prompt, model_list, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}
    }
    
    for model in model_list:
        model = model.strip()
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        for attempt in range(2):
            try:
                log(f"🔄 [{role.upper()}] Asking {model}...")
                resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
                
                if resp.status_code == 200:
                    try:
                        return resp.json()['candidates'][0]['content']['parts'][0]['text']
                    except: return None
                elif resp.status_code == 429:
                    log(f"⏳ {model} Rate Limit. Switching to backup...")
                    time.sleep(2)
                    break 
                elif resp.status_code == 404:
                    log(f"🚫 {model} not found. Switching...")
                    break
                else:
                    log(f"❌ Error {resp.status_code}: {resp.text[:100]}...")
                    
            except Exception as e:
                log(f"❌ Network Error: {e}")
    return None

# --- PATCH ENGINE ---
def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    if not matches: return None, "No blocks found."
    new_code = original
    applied_count = 0
    for search, replace in matches:
        if search in new_code:
            new_code = new_code.replace(search, replace)
            applied_count += 1
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
            applied_count += 1
        else:
            matcher = difflib.SequenceMatcher(None, new_code, search)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search))
            if match.size > 0 and (match.size / len(search) > 0.8):
                 new_code = new_code[:match.a] + replace + new_code[match.a + match.size:]
                 applied_count += 1
    return new_code, f"Applied {applied_count} patches"

# --- DEPLOYMENT ---
def check_render():
    if not RENDER_API_KEY: return
    log("🚀 Watching Render...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200 and resp.json()[0]['deploy']['status'] == "live":
                log("✅ Deployment Live.")
                return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED)"
        else:
            new_lines.append(line)
    if task_line:
        new_lines.append(""); new_lines.append("## ⚠️ SKIPPED TASKS"); new_lines.append(task_line)
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    context = read_file("AGENTS.md")
    history = ""
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        prompt = f"TASK: {task}\nCONTEXT: {context}\nERRORS: {history}\nCODE:\n{code}\n\nINSTRUCTIONS: Return SEARCH/REPLACE blocks. NO markdown."
        patch = ask_gemini(prompt, CODER_MODELS, role="coder")
        if not patch: continue
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
        log("✅ Verified. Committing...")
        write_file("index.html", new_code)
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        check_render()
        return True
    move_task_to_bottom(task)
    return True

if __name__ == "__main__":
    if test_connection():
        log("🤖 Jules Level 27 (FRESH MODELS) Started...")
        while process_task():
            time.sleep(5)
    else:
        log("🛑 Aborting.")

================================================================================
=== FILE: v40_20260116_1357_LEVEL_29_FIXED_BACKUPS.py
=== DATE: 01/16/2026 13:57:01
=== NOTE: Fixed 404 errors by using canonical model names (1.5-flash, 1.5-pro)
================================================================================
import os
import re
import git
import requests
import json
import time
import sys
import difflib
from datetime import datetime

# --- CONFIGURATION ---
REPO_PATH = "."
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "").replace("\n", "").strip()
RENDER_API_KEY = os.environ.get("RENDER_API_KEY", "").replace("\n", "").strip()
RENDER_SERVICE_ID = os.environ.get("RENDER_SERVICE_ID", "").replace("\n", "").strip()

# --- MODEL STACK (CANONICAL NAMES) ---
# We removed '-latest' which caused 404s.
# We added '1.5-pro' because it has a separate rate limit from Flash.
CODER_MODELS = [
    "gemini-2.0-flash",       # Primary (Currently Rate Limited)
    "gemini-1.5-flash",       # Backup 1 (Standard Name)
    "gemini-1.5-pro",         # Backup 2 (High Logic, Separate Quota)
    "gemini-1.5-flash-8b"     # Backup 3 (High Availability)
]

MAX_QA_RETRIES = 4
REQUEST_TIMEOUT = 90

def log(message):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}", flush=True)

if not GEMINI_API_KEY:
    log("❌ ERROR: GEMINI_API_KEY missing!")
    sys.exit(1)

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f: return f.read()
    except: return ""

def write_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f: f.write(content)

# --- PRE-FLIGHT ---
def test_connection():
    # We test the *second* model in the list since we know the first might be rate limited
    test_model = CODER_MODELS[1]
    log(f"🔌 Testing Connection with {test_model}...")
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{test_model}:generateContent?key={GEMINI_API_KEY}"
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": "Hello"}]}]}
    try:
        resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=10)
        if resp.status_code == 200:
            log("✅ Connection Valid.")
            return True
        else:
            log(f"❌ Connection Failed: {resp.status_code} - {resp.text}")
            return False
    except Exception as e:
        log(f"❌ Network Error: {e}")
        return False

# --- API ENGINE ---
def ask_gemini(prompt, model_list, role="coder"):
    if isinstance(model_list, str): model_list = [model_list]
    
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"maxOutputTokens": 8192, "temperature": 0.1}
    }
    
    for model in model_list:
        model = model.strip()
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
        
        for attempt in range(2):
            try:
                log(f"🔄 [{role.upper()}] Asking {model}...")
                resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=REQUEST_TIMEOUT)
                
                if resp.status_code == 200:
                    try:
                        return resp.json()['candidates'][0]['content']['parts'][0]['text']
                    except: return None
                elif resp.status_code == 429:
                    log(f"⏳ {model} Rate Limit. Switching...")
                    time.sleep(1) # Short sleep, then switch immediately
                    break 
                elif resp.status_code == 404:
                    log(f"🚫 {model} not found. Switching...")
                    break
                else:
                    log(f"❌ Error {resp.status_code}: {resp.text[:100]}...")
            except Exception as e:
                log(f"❌ Network Error: {e}")
    return None

# --- PATCH ENGINE ---
def apply_patch(original, patch):
    clean_patch = re.sub(r'^`[a-zA-Z]*\s*$', '', patch, flags=re.MULTILINE).strip()
    
    pattern = r"<<<<<<< SEARCH\s*\n(.*?)\n=======\n(.*?)\n>>>>>>> REPLACE"
    matches = re.findall(pattern, clean_patch, re.DOTALL)
    
    if not matches:
        log("⚠️ DEBUG: PARSING FAILED. RAW MODEL RESPONSE:")
        log("---------------------------------------------------")
        log(clean_patch[:500] + "..." if len(clean_patch) > 500 else clean_patch)
        log("---------------------------------------------------")
        return None, "No blocks found."
    
    new_code = original
    applied_count = 0
    
    for search, replace in matches:
        if search in new_code:
            new_code = new_code.replace(search, replace)
            applied_count += 1
        elif search.strip() in new_code:
            new_code = new_code.replace(search.strip(), replace.strip())
            applied_count += 1
        else:
            matcher = difflib.SequenceMatcher(None, new_code, search)
            match = matcher.find_longest_match(0, len(new_code), 0, len(search))
            if match.size > 0 and (match.size / len(search) > 0.8):
                 new_code = new_code[:match.a] + replace + new_code[match.a + match.size:]
                 applied_count += 1

    return new_code, f"Applied {applied_count} patches"

# --- DEPLOYMENT ---
def check_render():
    if not RENDER_API_KEY: return
    log("🚀 Watching Render...")
    url = f"[https://api.render.com/v1/services/](https://api.render.com/v1/services/){RENDER_SERVICE_ID}/deploys?limit=1"
    headers = {"Authorization": f"Bearer {RENDER_API_KEY}"}
    for _ in range(20):
        try:
            resp = requests.get(url, headers=headers)
            if resp.status_code == 200 and resp.json()[0]['deploy']['status'] == "live":
                log("✅ Deployment Live.")
                return
        except: pass
        time.sleep(15)

def move_task_to_bottom(task_name):
    content = read_file("BACKLOG.md")
    lines = content.splitlines()
    new_lines = []
    task_line = ""
    for line in lines:
        if f"- [ ] **{task_name}**" in line:
            task_line = f"- [ ] **{task_name}** (SKIPPED)"
        else:
            new_lines.append(line)
    if task_line:
        new_lines.append(""); new_lines.append("## ⚠️ SKIPPED TASKS"); new_lines.append(task_line)
    write_file("BACKLOG.md", "\n".join(new_lines))

# --- MAIN ---
def process_task():
    backlog = read_file("BACKLOG.md")
    match = re.search(r'- \[ \] \*\*(.*?)\*\*(?!\s*\(SKIPPED)', backlog)
    if not match: return False
    task = match.group(1).strip()
    
    log(f"\n📋 TARGET: {task}")
    code = read_file("index.html")
    context = read_file("AGENTS.md")
    history = ""
    
    for attempt in range(MAX_QA_RETRIES):
        log(f"💡 Attempt {attempt+1}/{MAX_QA_RETRIES}...")
        
        prompt = f"""
TASK: {task}
CONTEXT: {context}
ERRORS: {history}
CODE:
{code}

IMPORTANT INSTRUCTIONS:
1. You are a CODE GENERATOR, not a chat bot.
2. Output ONLY the SEARCH/REPLACE blocks.
3. DO NOT include any conversational text like "Here is the code".
4. FORMAT:
<<<<<<< SEARCH
(exact lines to remove)
=======
(new lines to insert)
>>>>>>> REPLACE
"""
        patch = ask_gemini(prompt, CODER_MODELS, role="coder")
        if not patch: continue
        
        new_code, status = apply_patch(code, patch)
        if not new_code:
            log(f"❌ Patch Failed: {status}")
            history = status
            continue
            
        log("✅ Verified. Committing...")
        write_file("index.html", new_code)
        
        new_backlog = read_file("BACKLOG.md").replace(f"- [ ] **{task}**", f"- [x] **{task}**")
        write_file("BACKLOG.md", new_backlog)
        
        repo = git.Repo(REPO_PATH)
        repo.git.add(all=True)
        repo.index.commit(f"feat(jules): {task}")
        repo.remotes.origin.push()
        check_render()
        return True

    move_task_to_bottom(task)
    return True

if __name__ == "__main__":
    if test_connection():
        log("🤖 Jules Level 29 (BACKUP MODELS FIXED) Started...")
        while process_task():
            time.sleep(5)
    else:
        log("🛑 Aborting.")
